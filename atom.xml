<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coder</title>
  <subtitle>Trying the best, expecting the worst.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.mkdef.com/"/>
  <updated>2016-11-26T09:44:53.000Z</updated>
  <id>http://blog.mkdef.com/</id>
  
  <author>
    <name>无生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>建立自己的ngrok服务</title>
    <link href="http://blog.mkdef.com/2016/09/26/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84ngrok%E6%9C%8D%E5%8A%A1/"/>
    <id>http://blog.mkdef.com/2016/09/26/建立自己的ngrok服务/</id>
    <published>2016-09-26T14:40:09.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<div class="figure"><img src="/uploads/GO_16.png"></div><h2 id="需求">需求</h2><p>两个需求：</p><ol style="list-style-type:decimal"><li>组里采购了一台服务器，托管在所里的机房里，但是到目前为止还没有分配外网ip，所以需要一个将本地端口暴露在外网的解决方案；</li><li>台式机是使用的所里的内网，但是本本用的路由。而且偶尔会需要离开工位，此时如果想用本本连到台式机，也需要将本地端口暴露到外网；</li></ol><p>用过的解决方案，都是基于ngrok的：</p><p>国内的ngrok.cc，其实挺好用的，虽然速度上慢了一点。但是这次升级了版本之后，配置文件的写法没有公布出来，而且如果总是变的话也不是个长久的办法。加上这次服务器被攻击，直接关闭了三天免费服务器，这一点是无法容忍的。</p><p>原生的ngrok.io。配置比ngrok.cc要简单一点，但是服务器在美帝，更加慢了。免费版本随机出来的域名实在太难记了，而且每次都会变。并且不能绑定自己的域名，导致这个服务就今天拿来临时用了一下。</p><h2 id="初步方案">初步方案</h2><p>自然还是用自己的服务器转发一下比较好。不过有两个问题，第一个是自己的服务器也不稳定，第二个是自己的服务器也在美帝。所以这个方案也只能是临时。但之后所里的服务器会有外网ip了，也就不需要这个服务了。其次，之后也许可以在所里的服务器上搭一个ngrok的server，这样就能以很快的速度登录到我的机器了(也许不能的原因是要绑定域名，而这个似乎很困难）</p><h3 id="安装golang">安装golang</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install build-essential</div><div class="line">sudo apt-get install golang</div><div class="line">sudo apt-get install mercurial</div></pre></td></tr></table></figure><p>然而我的<code>ubuntu</code>版本似乎太低，安装好的go是1.0的。所以要自己安装高等级的版本，我这里安装的是1.6的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo curl -O https://storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz</div><div class="line">sudo tar -xvf go1.6.linux-amd64.tar.gz</div><div class="line">sudo mv go /usr/local</div></pre></td></tr></table></figure><p>然后编辑profile，将go的路劲添加到系统路径里。然而我并没有成功。于是，我采用了很暴力的解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ln -s /usr/local/go/bin/go /usr/bin/go</div></pre></td></tr></table></figure><p>然后可以运行一下，查看是否安装成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go version</div></pre></td></tr></table></figure><h3 id="下载编译ngrok">下载编译ngrok</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/inconshreveable/ngrok.git ngrok</div><div class="line">cd ngrok</div></pre></td></tr></table></figure><p>接下来，是生成自认证的证书，这里我直接引用人家的一段解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Once it has finished cloning ngrok to your local machine, there is yet another thing you will need to do before you can build and compile your very own ngrok server and client and that is to create your own self-signed SSL certificate and this is required because ngrok provides the secure tunnel via TLS and in order for both the client and server to work you will need to build and compile ngrok using your self signed SSL certificate and these are linked to each other. So you cannot connect to your self-signed ngrokd server via the official ngrok client as both the server and client need to be signed using the same certificate.</div></pre></td></tr></table></figure><p>然后是生成证书的命令，需要将<code>NGROK_BASE_DOMAIN</code>替换成自己的域名，例如我的就是“tunnel.mkdef.com”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -out base.key 2048</div><div class="line">openssl req -new -x509 -nodes -key base.key -days 10000 -subj &quot;/CN=[NGROK_BASE_DOMAIN]&quot; -out base.pem</div><div class="line">openssl genrsa -out server.key 2048</div><div class="line">openssl req -new -key server.key -subj &quot;/CN=[NGROK_BASE_DOMAIN]&quot; -out server.csr</div><div class="line">openssl x509 -req -in server.csr -CA base.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crt</div></pre></td></tr></table></figure><p>然后需要去托管域名的网站添加一条解析规则，例如我托管在DNSpod上了。 最后终于可以编译了！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp base.pem assets/client/tls/ngrokroot.crt</div><div class="line">make release-server release-client</div></pre></td></tr></table></figure><p>生成的服务端和客户端在<code>bin</code>目录下。</p><h2 id="运行测试">运行测试</h2><h3 id="服务端">服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=&quot;[NGROK_BASE_DOMAIN]&quot; -httpAddr=&quot;:8080&quot; -httpsAddr=&quot;:8081&quot;</div></pre></td></tr></table></figure><p>然后打开浏览器，访问一下你配置的网站就好了，例如“http://tunnel.mkdef.com:8080”。 看到提示说<code>Tunnel not found</code>就表示成功了。</p><h3 id="客户端">客户端</h3><p>首先编写配置文件<code>ngrok.cfg</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">server_addr: [NGROK_BASE_DOMAIN]:4443</div><div class="line">trust_host_root_certs: false</div></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./ngrok -subdomain testing -config=ngrok.cfg 80</div></pre></td></tr></table></figure><p>这样你就能通过 <code>testing.tunnel.mkdef.com:8080</code> 来访问你本地的80端口了。</p><p>如果是tcp连接，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./ngrok -config=ngrok.cfg -proto tcp 22</div></pre></td></tr></table></figure><p>这是会显示出一个端口，似乎是随机的，不过好在反复执行是不变的，然后通过这个端口就能登录到你的本地机器了。没有测试多次执行是什么情况。</p><h2 id="todo">TODO</h2><p>目前为止只解决了部分需求，因为这个新的外网网址实在太长了，而且端口不是默认端口，所以至少还需要一步端口转发。</p><h2 id="reference">Reference</h2><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-go-1-6-on-ubuntu-14-04" target="_blank" rel="external">How To Install Go 1.6 on Ubuntu 14.04</a></p><p><a href="https://www.svenbit.com/2014/09/run-ngrok-on-your-own-server/" target="_blank" rel="external">Run Ngrok on Your Own Server Using Self-Signed SSL Certificate</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;figure&quot;&gt;&lt;img src=&quot;/uploads/GO_16.png&quot;&gt;&lt;/div&gt;&lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;&lt;p&gt;两个需求：&lt;/p&gt;&lt;ol style=&quot;list-style-type:decimal&quot;&gt;&lt;li&gt;组里采购了一台服务器，托管
    
    </summary>
    
    
      <category term="ngrok" scheme="http://blog.mkdef.com/tags/ngrok/"/>
    
      <category term="DNS" scheme="http://blog.mkdef.com/tags/DNS/"/>
    
      <category term="go" scheme="http://blog.mkdef.com/tags/go/"/>
    
      <category term="ubuntu" scheme="http://blog.mkdef.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Git 简明指南</title>
    <link href="http://blog.mkdef.com/2016/08/29/Git-%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97/"/>
    <id>http://blog.mkdef.com/2016/08/29/Git-简明指南/</id>
    <published>2016-08-29T06:05:57.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-github-介绍">Git &amp; Github 介绍</h2><p>Git首先是一个版本控制系统，它可以持续的追踪你的文件变化情况，从而通过Git，你可以将编辑过的文件恢复到之前的状态，也可以方便查看编辑前后文件内容的差异。</p><p>同时，Git也是一个分布式的版本控制系统，对于用户来说，主要体现在允许多个用户协同开发，同时修改代码库。</p><p>Github则是一个可以托管代码的平台，同时提供了Web的管理界面和一系列相关的开发服务和功能，功能稳定速度较快，所以在其上托管的项目非常之多，所以用来作为我们的项目托管平台应该是最好的选择。</p><h2 id="下载安装">下载安装</h2><p>有各种各样的工具可以实现Git的功能，但是由于我们主要采用Github作为托管平台，首先推荐的就是Github自己的图形界面工具： <a href="https://desktop.github.com/" target="_blank" rel="external">Github Desktop</a></p><p>命令行下只要安装Git就可以了。</p><p>事实上，目前大部分的IDE都自带或者通过插件实现了Git的所有功能，像：IntelliJ的所有IDE(包括Android Studio)，Visual Studio， Sublime Text等等。</p><p>具体的使用方法请自行谷歌。其实只要掌握了基本的Git命令，各种工具其实都大同小异。</p><h2 id="git基本概念">Git基本概念</h2><p>首先每个都有一个远端服务器仓库，所有的代码都会最终被提交到这里。开发环境中每个开发者都会有一个本地的代码仓库，由于新的代码通常是被开发者首先添加到本地代码仓库中，然后在提交到远端服务器上，所以本地代码的版本通常都要比远端服务器新。但是，如果有其他开发者提交了新的代码到远端服务器，那么这个时候Git就会告诉你，你本地的代码落后于远端服务器版本了，那么你可以选择是否下载最新的版本。</p><p>除了开发环境，一个完整的环节应该还包括测试和生产环境，这两个环境的代码都应该对应于远端服务器中的某一个比较完善的版本，远远落后于服务器上的最新版本。且通常只下载代码，不提交代码，也就是它不会对服务器上的版本做任何的改变。这两个环境与我们的项目都关系不大。</p><h2 id="新建或者下载一个本地仓库">新建或者下载一个本地仓库</h2><p>如果你已经有了一个本地项目，想要使用Git进行版本控制(哪怕你只是新建了一个空的文件夹，还没有任何代码也可以)，这个时候你只需要使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure><p>就可以创建一个新的Git仓库了。</p><p>如果你的项目已经有了一个远程的项目仓库(例如我们的代码库是：<a href="git@github.com:yubozu/Parkinson_Health.git">git@github.com:saukymo/Parkinson_Health.git</a>)，那么我们只需要复制一份远端代码库到本地就可以了，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:yubozu/Parkinson_Health.git</div></pre></td></tr></table></figure><p>此时，默认下载的最新版本的代码，当然你也可以选择下载某一特定版本的代码，这里不多说。</p><h2 id="本地仓库">本地仓库</h2><p>本地仓库由三个部分组成，首先是你的工作目录，里面是你的实际项目文件，例如代码、配置等等，第二个是暂存区(stage)，它像是一个缓存区域，你可以随时将修改过的文件添加到暂存区里来，对于这些文件的<em>最新</em>改动都会被记录下来，你可以随时查看它们和之前的区别(diff)。最后一个就是你的版本树(HEAD)了，你需要将暂存区里的改动提交到这里来(commit)，此时就好像给你的项目照了一个快照，目前所有的状态都被保存到了版本树的最前面了。</p><p>需要注意的是，暂存区和版本树都是用户不可见的(通常保存在项目根目录的<code>.git</code>文件夹中)，所以你可以放心的修改你的代码而不会影响到git的功能。 <img src="/uploads/trees.png"></p><h2 id="一般工作流程">一般工作流程</h2><p>首先，我们直接在修改本地工作目录的代码即可，开发过程与平时完全一样。当你完成一个阶段的开发(或者开发完一个小的功能，或者到了一定时间需要休息一下)时，这时就需要通过Git来提交你之前做的修改了。</p><h3 id="git-status">git status</h3><p>首先你需要查看一下本地文件的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure><p>这时你将看到你的项目文件中，有哪些被添加到了暂存区中，有哪些还没有(通常是新增加的文件，因为一般来说，一个文件只要被添加到暂存区中一次，它就会一直在暂存区中，不用每次都添加进来)。</p><h3 id="git-diff">git diff</h3><p>然后你可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure><p>来查看你对这些文件做了哪些修改，改动都是放在一起显示的，红色的代表以前的状态，绿色代表现在的状态。由于这些改动都是你刚刚进行的，所以应该有比较深的印象，这时你应该简单的浏览一遍，回顾一下你做了哪些改动，有没有遗漏(例如 TODO)或者多余的修改(例如 调试时多余的输出等)。</p><p><code>diff</code>过程命令行下不是很方便，这时候通过IDE自带的比对工具会方便一些。</p><h3 id="git-commit">git commit</h3><p>确认无误后，你就可以提交你的代码了，使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit</div></pre></td></tr></table></figure><p><code>commit</code>的时候需要填写你本次提交做了哪些修改，这样之后自己和别人查看时能很快了解这次提交做了哪些修改。</p><p>以上做的所有步骤都是在本地进行的，改动的也只是你的本地代码仓库。如果你仅仅需要一个版本控制功能，那么到这一步就可以了，但是我们的项目是托管在远端服务器上的，所以我们还需要将本地的修改提交到远端服务器上，这样其他人也就能获得和使用我们的代码了。</p><p>如果改动不多，我们也可以用一条命令完成提交(commit)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;This is an example commit comment.&quot;</div></pre></td></tr></table></figure><h3 id="git-push">git push</h3><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push</div></pre></td></tr></table></figure><p>这条命令就会将你之前在本地代码仓库进行的所有提交(commit)一次性全部添加到远程代码仓库上去。</p><h2 id="分支">分支</h2><p>本篇教程不会写关于冲突的处理，但需要了解的是，当两个甚至多个人对同一块代码进行改动的时候，会出现冲突的情况。如果大家一直都在一起改，那么每次提交都会有冲突的可能，这样显然是效率很低的。所以，为了尽量使不同开发者之间的开发不互相影响，Git有一个分支的概念。</p><div class="figure"><img src="/uploads/branches.png"></div><p>当你新建仓库的时候，默认是在“master”分支上的，你可以新建一个新的分支，在新的分支上进行开发，此时这个新分支只有你一个人在开发，是完全独立于其他开发人员的，当开发完成后，再将它们合并(merge)到主分支上(可以是master，也可以是任何约定好的分支)。这样，只有在最后合并(merge)的时候才需要处理冲突的情况。</p><h3 id="新建分支">新建分支</h3><p>通过以下命令可以新建一个名字为<code>new_branch</code>的branch，在你第一次提交(push)代码到远端服务器上之前，这个分支不会被其他人看到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch new_branch</div></pre></td></tr></table></figure><h3 id="列出和切换分支">列出和切换分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch -l</div><div class="line">git checkout new_branch</div></pre></td></tr></table></figure><p>第一个命令可以列出本地代码有哪些分支，第二个命令可以切换到任意一个分支。</p><h3 id="提交分支到远端服务器">提交分支到远端服务器</h3><p>当你在这个分支上的修改完成后，你可以先按照前面的一般工作流程进行操作，当你第一次输入<code>git push</code>后，git会告诉你说这个分支在远端服务器没有对应的分支。此时你可以使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin new_branch</div></pre></td></tr></table></figure><p>来设置这个分支对应的远端分支(分支采用相同的名字)，之后再提交更改的时候，直接使用<code>git push</code>即可。</p><h3 id="合并代码">合并代码</h3><p>当你的功能开发完成之后，可以到Github网站上去提交一个合并申请(pull request)，此时其他成员就会收到你的申请，他们也可以看到你这次更新所做的所有修改。</p><p>此时，不管你有没有权限进行服务器端的合并(merge)操作，都建议你留一些时间(1~2天)给其他开发者，让他们来审核你的代码(Code review)。这个过程不仅能提高项目的代码质量，也是一个很好的学习编程的方式。所以，也建议你在看到其他人的合并申请(pull request)时，主动的去review他们的代码，并留下自己的comments。</p><h3 id="删除分支">删除分支</h3><p>由于我们采用基于分支的开发流程，<code>pull request</code>被合并之后，会自动删除分支，所以一般不需要这个命令，但有时候我们可能会不小心新建一个分支，那么就可以用下面这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d new_branch</div></pre></td></tr></table></figure><h2 id="更新与合并">更新与合并</h2><p>如果你要与其他人合作开发，在你每次开始工作前，都应该检查其他人是否有提交新的代码，如果有的话，你应该先将他们的代码下载下来。使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull</div></pre></td></tr></table></figure><p>此时，会将远端的最新代码覆盖到本地，那么这里有个潜在的可能会要处理冲突。</p><p>但是，按照我们的开发流程，我们不会提交代码到master分支，其他分支都是自己所独有的。所以理论上这个操作仅仅是更新代码到最新的版本，而不需要处理冲突。</p><h2 id="回滚代码">回滚代码</h2><p>希望你永远不需要用到这个部分的功能。当你需要回到之前的某个版本时，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard</div></pre></td></tr></table></figure><p>此时所有没有提交的改动都会还原到上一次提交的地方。</p><p>再往前的回滚一般不会用到。</p><h2 id="写在最后">写在最后</h2><p>基于Git的开发是现在最基本的开发流程，不管是用来管理个人项目，还是协同开发都是非常好用的，希望大家都能很快的掌握。学习过程肯定是很痛苦的，但是熟悉和习惯之后这些额外的操作其实代价非常小，甚至可以将commit操作当做保存操作一样频繁的使用。</p><p>其实这个流程对于我们这样的小团队来说，略微有一点点复杂了，但是这个流程最重要的地方其实是进行Code review。这个流程给每个人Review团队中其他人代码的机会，正如前文所说，这个过程既提高了代码质量，也提高了自己的编程水平。目前这个Review的过程不是必须的，但是希望大家都能积极的参与进来。</p><p>最后，这个指南肯定会有各种各样的错误和疏(sheng)漏(lue)，如果有遇到任何的问题，我们可以一起解决。如果有任何的建议，我们也可以再讨论，做出改进。</p><p>最后的最后，希望大家能够善于利用搜索引擎来解决编程方面的问题。如果可以报销的话，可以为大家提供谷(fan)歌(qiang)的解决方案。</p><h2 id="参考文献">参考文献</h2><p><a href="http://rogerdudler.github.io/git-guide/index.html" target="_blank" rel="external">设计很棒的Git教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git-github-介绍&quot;&gt;Git &amp;amp; Github 介绍&lt;/h2&gt;&lt;p&gt;Git首先是一个版本控制系统，它可以持续的追踪你的文件变化情况，从而通过Git，你可以将编辑过的文件恢复到之前的状态，也可以方便查看编辑前后文件内容的差异。&lt;/p&gt;&lt;p&gt;同时，Gi
    
    </summary>
    
    
      <category term="Git" scheme="http://blog.mkdef.com/tags/Git/"/>
    
      <category term="Github" scheme="http://blog.mkdef.com/tags/Github/"/>
    
      <category term="Code review" scheme="http://blog.mkdef.com/tags/Code-review/"/>
    
  </entry>
  
  <entry>
    <title>Macos安装Caffe和pyCaffe</title>
    <link href="http://blog.mkdef.com/2016/08/19/Macos%E5%AE%89%E8%A3%85Caffe%E5%92%8CpyCaffe/"/>
    <id>http://blog.mkdef.com/2016/08/19/Macos安装Caffe和pyCaffe/</id>
    <published>2016-08-19T05:21:35.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考阅读">参考阅读</h2><p>其实主要是翻译的官方文档，官方文档主要是比较全面，各种情况都要考虑到，所以内容比较分散，而很多细节容易被忽略掉。但是如果具体我自己的安装需求，情况比较单一，所以相比之下更加清晰一点。</p><p><a href="http://caffe.berkeleyvision.org/install_osx.html" target="_blank" rel="external">Macos依赖安装</a> <a href="http://caffe.berkeleyvision.org/installation.html#compilation" target="_blank" rel="external">源码编译</a></p><h2 id="安装依赖包">安装依赖包</h2><p>官方的代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">brew install -vd snappy leveldb gflags glog szip lmdb</div><div class="line"># need the homebrew science source for OpenCV and hdf5</div><div class="line">brew tap homebrew/science</div><div class="line">brew install hdf5 opencv</div></pre></td></tr></table></figure><p>依次安装就好，每个包的作用如下：</p><h3 id="snappy">snappy</h3><p>用于压缩和解压文件</p><h3 id="leveldb-lmdb">leveldb &amp; lmdb</h3><p>将各种原始数据通过Key-Value键值对的方式存储在内存中，方便Caffe的DataLayer获取这些数据。 lmdb是比较新的数据管理库，leveldb是比较老的版本，但是为了兼容，仍然保留了这个库。</p><h3 id="gflags">gflags</h3><p>解析命令行参数。</p><h3 id="glog">glog</h3><p>日志记录。</p><h3 id="blas">BLAS</h3><p>我不记得有安装这个，可能之前其他项目有装过，这个是主要的矩阵、向量计算的库。根据文档，应该默认使用的<code>ATLAS</code>库。</p><h3 id="hdf5">HDF5</h3><p>统一的数据存储格式。</p><h3 id="opencv">OpenCV</h3><p>Caffe仅仅使用了图片读写、缩放等基本操作。</p><h2 id="安装pycaffe其他依赖包">安装pyCaffe其他依赖包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pip install scikit-image</div><div class="line">pip install scipy</div><div class="line">pip install matplotlib</div><div class="line">pip install protobuf</div></pre></td></tr></table></figure><h2 id="编译源码">编译源码</h2><p>首先，使用默认的配置文件作为我们编译过程的基础配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp Makefile.config.example Makefile.config</div></pre></td></tr></table></figure><p>由于我的mbp没有可用的GPU，所以将配置文件里的<code>CPU_ONLY := 1</code>项去掉注释。</p><p>然后依次执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">make all -j8</div><div class="line">make test</div><div class="line">make runtest</div></pre></td></tr></table></figure><p>其中，<code>make all -j8</code>中的数字代表并行编译的线程，依据机器的真实情况修改，可以极大地提高编译的速度。</p><p>最后编译pyCaffe即可，需要修改makefile.config里的python和numpy目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make pycaffe</div></pre></td></tr></table></figure><h2 id="小结">小结</h2><p>这一次安装的异常顺利，远远没有年前那次安装得痛苦。期望之后通过使用<code>Caffe</code>学到三个方面的内容，第一当然是深度学习模型的原理、训练、使用等；第二是通过阅读源码学习<code>C++</code>的程序结构和各类库的使用；第三是<code>Python</code>和<code>C++</code>的接口实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;&lt;p&gt;其实主要是翻译的官方文档，官方文档主要是比较全面，各种情况都要考虑到，所以内容比较分散，而很多细节容易被忽略掉。但是如果具体我自己的安装需求，情况比较单一，所以相比之下更加清晰一点。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://
    
    </summary>
    
    
      <category term="Caffe" scheme="http://blog.mkdef.com/tags/Caffe/"/>
    
      <category term="MacOS" scheme="http://blog.mkdef.com/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>vps + shadowsocks + switchOmega科学上网</title>
    <link href="http://blog.mkdef.com/2016/08/18/vps-shadowsocks-switchOmega%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://blog.mkdef.com/2016/08/18/vps-shadowsocks-switchOmega科学上网/</id>
    <published>2016-08-18T06:55:11.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>之前用了一段时间的<code>Lantern</code>，虽然很好用，但是流量消耗得太快，跑了一天就超过了80%。正好早上登上了<code>budgetvm</code>的vps整了下数据库，所以就想顺便再把代理捣鼓一下。</p><div class="figure"><img src="/uploads/shadowsocks.png"></div><h2 id="经过">经过</h2><p>借着<code>Lantern</code>剩下的一点流量，没费多少功夫就搜到了神器<a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="external">shadowsocks</a>，但是很遗憾，似乎作者停止更新了。不过好在wiki还是完整的，开始按照wiki折腾了很久，不得要领。遂请教胡神，胡神很给力的给了给了一套教程<a href="https://github.com/sjtug/kxsw/wiki" target="_blank" rel="external">Get Through the Firewall in Scientific Method</a>。按照教程捣鼓了一番，还是不得要领。最后在胡神亲自带领下，终于成功翻墙，于是写下这篇笔记记录一下方法。</p><p>基本按照这个图来</p><pre><code>+-------------------------------------+
|       Server A(大陆以外)             |
|    运行shadowsocks-python服务端      |
| 对外提供的SS IP为ip1，端口为port1      |
+--------------+----------------------+
           |
           |
           |
+--------------+-------------------------------------------+
|     本机                                                 |
| 运行shadowsocks-python客户端 + switchOmega socks5代理     |
+----------------------------------------------------------+</code></pre><p>本来为了方便使用，应该是在墙内设置一个Server B，然后在B上运行<code>shadowsocks</code>客户端，同时添加<code>cow</code>的二级代理，转成<code>http</code>代理，然后就方便使用了，但是测试了半天没有成功，改用上面的这种简化的方法。缺点在于本机需要运行客户端才可以开启代理。不过都设置好之后也还算方便。</p><h2 id="服务器端墙外vps安装和配置">服务器端(墙外VPS)安装和配置</h2><p>首先安装<code>shadowsocks</code>，因为绑定1000以下端口和后台运行都是需要<code>sudo</code>权限的，所以需要直接在系统库中安装会比较方便一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install shadowsocks</div></pre></td></tr></table></figure><p>安装完之后就可以直接运行<code>ssserver</code>命令了。 首先写服务端的配置文件<code>shadowsocks.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="attr">"server"</span>:<span class="string">"▇▇.▇▇.▇▇.▇▇"</span>,</div><div class="line">        <span class="attr">"server_port"</span>:<span class="number">9000</span>,</div><div class="line">        <span class="attr">"password"</span>:<span class="string">"FUCKXXX"</span>,</div><div class="line">        <span class="attr">"timeout"</span>:<span class="number">300</span>,</div><div class="line">        <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssserver -c shadowsocks.json</div></pre></td></tr></table></figure><p>或者后台运行，可能需要<code>sudo</code>权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssserver -c shadowsocks.json -d start</div></pre></td></tr></table></figure><p>这个时候服务器端的配置就完成了。</p><h2 id="客户端本机或国内vps配置">客户端(本机或国内VPS)配置</h2><p>安装和运行方式同上，只有配置文件略有不同</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="attr">"server"</span>:<span class="string">"▇▇.▇▇.▇▇.▇▇"</span>,</div><div class="line">        <span class="attr">"server_port"</span>:<span class="number">9000</span>,</div><div class="line">        <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</div><div class="line">        <span class="attr">"local_port"</span>:<span class="number">443</span>,</div><div class="line">        <span class="attr">"password"</span>:<span class="string">"FUCKXXX"</span>,</div><div class="line">        <span class="attr">"timeout"</span>:<span class="number">300</span>,</div><div class="line">        <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来，本机就有了一个ip为<code>127.0.0.1</code>，端口为<code>443</code>的<code>socks5</code>代理了。</p><h2 id="switchomega配置">SwitchOmega配置</h2><p><code>SwitchOmega</code>需要先翻墙在<code>Chrome</code>商店进行安装，安装完之后添加刚才设置好的<code>socks5</code>代理即可。</p><p>但是<code>SwitchOmega</code>还需要设置自动代理，这样可以直接访问国内的网站而不用代理。打开插件的设置页面，选择<code>auto switch</code>，在<code>Rule list</code>中选择<code>AutoProxy</code>，然后在网址填入<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>。点下载配置即可。</p><p>此时应该可以顺利翻墙了。</p><h2 id="dns污染">DNS污染</h2><p>这个概念我还没有搞清楚，也没有去折腾相关的解决方案，使用了胡神给的一个据说没有被污染的DNS，然后就能成功访问<code>Google</code>了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;之前用了一段时间的&lt;code&gt;Lantern&lt;/code&gt;，虽然很好用，但是流量消耗得太快，跑了一天就超过了80%。正好早上登上了&lt;code&gt;budgetvm&lt;/code&gt;的vps整了下数据库，所以就想顺便再把代理捣鼓一下。&lt;/p&gt;&lt;d
    
    </summary>
    
    
      <category term="shadowsocks" scheme="http://blog.mkdef.com/tags/shadowsocks/"/>
    
      <category term="SwitchOmega" scheme="http://blog.mkdef.com/tags/SwitchOmega/"/>
    
      <category term="GFW" scheme="http://blog.mkdef.com/tags/GFW/"/>
    
      <category term="socks5" scheme="http://blog.mkdef.com/tags/socks5/"/>
    
  </entry>
  
  <entry>
    <title>Ivita里使用Mysql的一些小技巧</title>
    <link href="http://blog.mkdef.com/2016/08/02/Ivita%E9%87%8C%E4%BD%BF%E7%94%A8Mysql%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://blog.mkdef.com/2016/08/02/Ivita里使用Mysql的一些小技巧/</id>
    <published>2016-08-02T03:39:19.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目背景">项目背景</h2><p>因为旅行计划与放假安排没有完全重叠，于是向老板申请调假，在小伙伴们都放高温假的时候，在实验室干活一周。于是被临时安排到了这个叫做<code>Ivita</code>项目里，做的东西其实就是一个手环app。不过因为是临时一周，之后出现问题不好解决，所以只负责了后端的几个API实现。技术框架原本就已经定好，<code>slimePHP + Medoo</code>，数据库是<code>Mysql</code>。然后由于懒癌发作，加上很多功能<code>Medoo</code>并不能实现，于是用了不少以前没有用过的SQL语句和设置。</p><h2 id="table设置">Table设置</h2><h3 id="create和update的自动记录时间触发">Create和Update的自动记录时间触发</h3><p>这个其实在用<code>Postgresql</code>的时候就已经用过了，结果发现<code>Mysql</code>更加简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</div><div class="line">   updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</div></pre></td></tr></table></figure><h3 id="多主键限制">多主键限制</h3><p><code>Ivita</code>里<code>uid</code>和<code>date</code>共同作为主键，所以需要给他们俩一起添加一个唯一性限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UNIQUE KEY (uid, date)</div></pre></td></tr></table></figure><h2 id="sql语句">SQL语句</h2><h3 id="分组求和并排序">分组求和并排序</h3><p>业务需求本来求和周年月的每日数据，然后返回一个排名，不过之后这个功能没有意义了，就没有用到这个功能了。这里贴一个更好的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT orderNumber,</div><div class="line">       FORMAT(SUM(quantityOrdered * priceEach),2) total</div><div class="line">FROM orderdetails</div><div class="line">GROUP BY orderNumber</div><div class="line">ORDER BY SUM(quantityOrdered * priceEach) DESC;</div></pre></td></tr></table></figure><h3 id="插入重复则更新">插入重复则更新</h3><p>很方便的一个功能，本来要写两条还要写代码判断的现在一句话就能解决了，不过<code>Ivita</code>用的<code>Mysql</code>版本不支持<code>Json</code>，所以不知道如果有的字段是<code>Json</code>的话，是不是依然还是那么方便。在<code>Ivita</code>里我把<code>Json</code>字段单独处理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">insert into steps (uid, date, count, calory, kilo) values ($&#123;id&#125;, $&#123;value&#125;, $&#123;data[&apos;count&apos;]&#125;, $&#123;data[&apos;calory&apos;]&#125;, $&#123;data[&apos;kilo&apos;]&#125;) on duplicate key update count=count+values(count), calory=calory+values(calory), kilo=kilo+values(kilo);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目背景&quot;&gt;项目背景&lt;/h2&gt;&lt;p&gt;因为旅行计划与放假安排没有完全重叠，于是向老板申请调假，在小伙伴们都放高温假的时候，在实验室干活一周。于是被临时安排到了这个叫做&lt;code&gt;Ivita&lt;/code&gt;项目里，做的东西其实就是一个手环app。不过因为是临时一周，之后
    
    </summary>
    
    
      <category term="Mysql" scheme="http://blog.mkdef.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>网站压力测试工具pyWebTest</title>
    <link href="http://blog.mkdef.com/2016/07/18/%E7%BD%91%E7%AB%99%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://blog.mkdef.com/2016/07/18/网站压力测试工具/</id>
    <published>2016-07-18T15:55:39.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目介绍">项目介绍</h2><p>pyWebTest是一个性能和负载测试工具，采用纯python编写，可以并发地对目标网站生成请求，测试响应时间和吞吐量，并生成完整的测试报告。</p><p>通过简单地修改测试部分的代码，可以很快的实现对远程API的压力测试，事实上，可以通过编写测试脚本，实现很多复杂的测试计划。</p><p>测试报告通过标准输出给出。(文件和网页形式的报告功能没有实现)</p><h2 id="使用说明">使用说明</h2><h3 id="下载和安装">下载和安装</h3><p>pyWebTest可以通过Git下载完整的源代码，并且不需要额外的设置就可以直接运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git clone git@github.com:saukymo/pyWebTest.git</div><div class="line">$ cd pyWebTest</div><div class="line">$ python main.py -h</div></pre></td></tr></table></figure><h3 id="使用方法">使用方法</h3><p>通过<code>-h</code>参数可以看到简单的参数介绍，一共有4个可选参数，<code>-a</code>是并发进程数，默认模拟两个用户请求网；，<code>-d</code>是测试时间，超过时间测试中止，设定时间之后的请求会被忽略，默认持续10秒；<code>-i</code>是统计时对数据采用的分段数，默认将整个测试分成10段统计；<code>-r</code>是启动进程的时间，所有的并发将在启动时间内均匀的开始，平稳地增加，启动时间到达后，达到预先设定的并发进程数，默认为0秒，即一开始就达到最大负载进行测试。<code>-u</code>是测试的目标网站，不能省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ python main.py -h</div><div class="line">usage: main.py [-h] [-a [A]] [-d [D]] [-i [I]] [-r [R]] -u U</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help  show this help message and exit</div><div class="line">  -a [A]      number of agents</div><div class="line">  -d [D]      test duration in seconds</div><div class="line">  -i [I]      number of time-seriels interval</div><div class="line">  -r [R]      rampup in seconds</div><div class="line">  -u U        test target url</div></pre></td></tr></table></figure><h3 id="测试和报告样例">测试和报告样例</h3><p>样例测试选择百度作为测试对象，一共产生20个用户模拟请求，测试一共持续30秒，统计分成10段，即3秒统计分析一次。启动时间10秒，即每0.5秒增加一个新的用户。测试的报告如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">python main.py -a 20 -d 30 -i 10 -r 10 -u http://www.baidu.com</div><div class="line"></div><div class="line">===Summary===</div><div class="line">transactions: 1788 hits</div><div class="line">errors: 0</div><div class="line">runtime: 30 secs</div><div class="line">rampup: 10 secs</div><div class="line">time-series interval: 3.000 secs</div><div class="line"></div><div class="line">test start: 2016-07-19 00:18:13</div><div class="line">test finish: 2016-07-19 00:18:43</div><div class="line"></div><div class="line">===All Transactions===</div><div class="line">Response Time Summary (secs):</div><div class="line">  count	    avg	    min	  50pct	  80pct	  90pct	    max	  stdev</div><div class="line">   1773	  0.283	  0.123	  0.293	  0.351	  0.396	  0.509	  0.076</div><div class="line"></div><div class="line">Interval Details (secs):</div><div class="line">interval	  count	    avg	    min	  50pct	  80pct	  90pct	    max	  stdev</div><div class="line">       0	     65	  0.155	  0.123	  0.160	  0.167	  0.169	  0.191	  0.015</div><div class="line">       1	    171	  0.164	  0.124	  0.163	  0.173	  0.193	  0.254	  0.022</div><div class="line">       2	    194	  0.230	  0.124	  0.245	  0.252	  0.258	  0.349	  0.040</div><div class="line">       3	    192	  0.306	  0.222	  0.299	  0.352	  0.400	  0.458	  0.055</div><div class="line">       4	    196	  0.308	  0.231	  0.299	  0.352	  0.396	  0.509	  0.056</div><div class="line">       5	    193	  0.313	  0.242	  0.300	  0.354	  0.399	  0.452	  0.054</div><div class="line">       6	    190	  0.312	  0.242	  0.300	  0.352	  0.399	  0.506	  0.058</div><div class="line">       7	    190	  0.314	  0.243	  0.302	  0.355	  0.402	  0.509	  0.058</div><div class="line">       8	    192	  0.313	  0.240	  0.301	  0.357	  0.403	  0.506	  0.061</div><div class="line">       9	    190	  0.316	  0.241	  0.299	  0.359	  0.405	  0.508	  0.069</div><div class="line"></div><div class="line">===Agent Details===</div><div class="line">Agent	Starttime	Requests	Errors	Bytes received	Avg Response Time(secs)	Avg throughput(req/sec)</div><div class="line">    0	     0.00	     118	     0	      11705655	                  0.256	                  3.904</div><div class="line">    1	     0.50	     113	     0	      11211349	                  0.263	                  3.801</div><div class="line">    2	     1.00	     112	     0	      11110130	                  0.259	                  3.859</div><div class="line">    3	     1.50	     109	     0	      10812108	                  0.263	                  3.805</div><div class="line">    4	     2.00	     107	     0	      10613035	                  0.263	                  3.802</div><div class="line">    5	     2.50	     100	     0	       9920078	                  0.276	                  3.627</div><div class="line">    6	     3.00	     100	     0	       9920273	                  0.272	                  3.680</div><div class="line">    7	     3.51	      95	     0	       9425688	                  0.281	                  3.555</div><div class="line">    8	     4.01	      94	     0	       9324440	                  0.278	                  3.599</div><div class="line">    9	     4.51	      89	     0	       8828827	                  0.287	                  3.488</div><div class="line">   10	     5.01	      86	     0	       8531848	                  0.291	                  3.438</div><div class="line">   11	     5.51	      82	     0	       8133568	                  0.299	                  3.345</div><div class="line">   12	     6.01	      83	     0	       8233050	                  0.290	                  3.442</div><div class="line">   13	     6.51	      79	     0	       7837821	                  0.298	                  3.359</div><div class="line">   14	     7.01	      76	     0	       7538452	                  0.306	                  3.270</div><div class="line">   15	     7.51	      75	     0	       7438603	                  0.302	                  3.314</div><div class="line">   16	     8.01	      70	     0	       6944360	                  0.316	                  3.165</div><div class="line">   17	     8.51	      72	     0	       7141987	                  0.301	                  3.316</div><div class="line">   18	     9.01	      67	     0	       6645907	                  0.314	                  3.181</div><div class="line">   19	     9.51	      66	     0	       6547565	                  0.311	                  3.217</div></pre></td></tr></table></figure><h2 id="项目模块和实现">项目模块和实现</h2><h3 id="运行参数分析">运行参数分析</h3><p>参数分析采用python的<code>argparse</code>模块，通过这个模块，可以很简单的增加可以设置的参数，可以设置参数类型，并且自动生成帮助文档。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arg_parser = argparse.ArgumentParser()</div><div class="line"></div><div class="line">arg_parser.add_argument(<span class="string">'-a'</span>, nargs=<span class="string">'?'</span>, help=<span class="string">'number of agents'</span>, default=<span class="number">2</span>)</div><div class="line">arg_parser.add_argument(<span class="string">'-d'</span>, nargs=<span class="string">'?'</span>, help=<span class="string">'test duration in seconds'</span>, default=<span class="number">10</span>)</div><div class="line">arg_parser.add_argument(<span class="string">'-i'</span>, nargs=<span class="string">'?'</span>, help=<span class="string">'number of time-seriels interval'</span>, default=<span class="number">10</span>)</div><div class="line">arg_parser.add_argument(<span class="string">'-r'</span>, nargs=<span class="string">'?'</span>, help=<span class="string">'rampup in seconds'</span>, default=<span class="number">0.0</span>)</div><div class="line">arg_parser.add_argument(<span class="string">'-u'</span>, help=<span class="string">'test target url'</span>, required=<span class="keyword">True</span>) </div><div class="line">args = vars(arg_parser.parse_args())</div></pre></td></tr></table></figure><p><code>args</code>就是一个包含所有参数的字典了，例如通过<code>args.get('i')</code>就可以获取用户运行时设置的参数i了。</p><h3 id="进程间通信">进程间通信</h3><p>虽然经过测试发现，多线程与多进程版本差别不大，所以最后改用多线程完成了整个项目，但在一开始还是使用的多进程版本。那么每个进程进行测试的结果就需要通过进程间通信的方式共享出来。这里采用生产者消费者模式的<code>Queue</code>来实现。</p><p>首先需要定义一个<code>QueueReader</code>类来充当消费者的形式，并在测试开始前开启这个进程，并且设置<code>daemon</code>属性为<code>True</code>，这样这个进程就会随着主进程结束一起结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">queue = multiprocessing.Queue()</div><div class="line">queue_reader = QueueReader(queue)</div><div class="line">queue_reader.daemon = <span class="keyword">True</span></div><div class="line">queue_reader.start()</div></pre></td></tr></table></figure><p>在每个测试进程中，将结果通过<code>Queue.put</code>方法将结果放到队列中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.queue.put(fields)</div></pre></td></tr></table></figure><p>队列满时，会产生<code>Queue.Full</code>错误，测试进程挂起，等待队列被消耗，队列空时，产生<code>Queue.Empty</code>错误，读取进程等待一小段时间(这里设置为0.05秒)</p><h3 id="测试进程管理">测试进程管理</h3><p>首先，将每个进程的预先设置好，然后启动一个全局的计时器，之后再依次开始每个进程的测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">threads = []</div><div class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(self.num_threads):</div><div class="line">    agent = Agent(self.queue, idx, self.run_time)</div><div class="line">    agent.daemon = <span class="keyword">True</span></div><div class="line">    threads.append(agent)</div><div class="line"></div><div class="line"><span class="keyword">for</span> idx, agent <span class="keyword">in</span> enumerate(threads):</div><div class="line">    spacing = <span class="number">1.0</span> * self.rampup / self.num_threads</div><div class="line">    <span class="keyword">if</span> idx &gt; <span class="number">0</span>:</div><div class="line">        time.sleep(spacing)</div><div class="line">    agent.start()</div><div class="line"></div><div class="line"><span class="keyword">for</span> agent <span class="keyword">in</span> threads:</div><div class="line">    agent.join()</div></pre></td></tr></table></figure><p>其中，<code>rampup</code>的功能是在第二个循环中实现的，首先计算每个进程的平均启动时间，然后等待足够的时间后再启动一个新的进程即可。</p><h3 id="测试进程实现">测试进程实现</h3><p>测试进程的部分其实很简单，其中真正的请求部分只有三行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">connect = urllib2.urlopen(url)</div><div class="line">content = connect.read()</div><div class="line">resp_data = len(content)</div></pre></td></tr></table></figure><p>通过修改这个部分的代码，可以实现对API的请求测试，也可以实现各种复杂的测试计划。</p><p>整个测试进程的框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">elapsed_time = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> elapsed_time &lt; self.run_time:</div><div class="line">    error = <span class="string">''</span></div><div class="line">    start = time.time()</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="comment"># 测试部分代码</span></div><div class="line">    <span class="keyword">except</span> Exception, e:</div><div class="line">        error = str(e)</div><div class="line"></div><div class="line">    run_time = time.time() - start</div><div class="line">    elapsed_time = time.time() - UNION_START_TIME</div><div class="line"></div><div class="line">    <span class="comment"># 测试结果field统计，然后将结果放到Queue中</span></div><div class="line">    Queue.put(field)</div></pre></td></tr></table></figure><h3 id="测试结果的统计">测试结果的统计</h3><p>统计分两个部分进行。一个是从每个进程的角度分析，统计每个进程的平均响应时间和吞吐量。这个在每个进程完成所有测试之后统计即可，在设置了<code>rampup</code>参数时，这个统计可以看出测试机器的性能对结果的影响，例如在进程较少时，平均响应时间较短，进程较多时，平均响应时间较长。</p><p>另外一个则是从时间分段的角度进行分析，统计不同阶段的响应时间及其分布情况，这个需要记录所有的测试结果之后，根据测试的时间分组统计。这个统计可以看出目标网站的性能情况，看出不同阶段，请求进程数不同时，目标网站的响应时间变化。</p><p>由于这部分代码零散的分布在测试的各个阶段，所以就不贴代码了。</p><p>如果目标网站的响应时间较长，而测试时间较短，可能出现某个时间成功响应次数为0的情况，这个时候统计函数会出错，所以需要给它们都加上一个特殊判断，这里采用装饰器的方法判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">validator</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_func</span><span class="params">(*args, **kargs)</span>:</span></div><div class="line">        <span class="keyword">if</span> len(args[<span class="number">0</span>]) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0.0</span></div><div class="line">        <span class="keyword">return</span> func(*args, **kargs)</div><div class="line">    <span class="keyword">return</span> _func</div><div class="line"></div><div class="line"><span class="meta">@validator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">minarg</span><span class="params">(seq)</span>:</span></div><div class="line">    <span class="keyword">return</span> min(seq)</div><div class="line"></div><div class="line"><span class="meta">@validator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxarg</span><span class="params">(seq)</span>:</span></div><div class="line">    <span class="keyword">return</span> max(seq)</div><div class="line"></div><div class="line"><span class="meta">@validator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(seq)</span>:</span></div><div class="line">    avg = (float(sum(seq)) / len(seq))</div><div class="line">    <span class="keyword">return</span> avg</div><div class="line"></div><div class="line"><span class="meta">@validator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">standard_dev</span><span class="params">(seq)</span>:</span></div><div class="line">    avg = average(seq)</div><div class="line">    sdsq = sum([(i - avg) ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> seq])</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        stdev = (sdsq / (len(seq) - <span class="number">1</span>)) ** <span class="number">.5</span></div><div class="line">    <span class="keyword">except</span> ZeroDivisionError:</div><div class="line">        stdev = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> stdev</div><div class="line"></div><div class="line"><span class="meta">@validator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">percentile</span><span class="params">(seq, percentile)</span>:</span></div><div class="line">    i = int(len(seq) * (percentile / <span class="number">100.0</span>))</div><div class="line">    seq.sort()</div><div class="line">    <span class="keyword">return</span> seq[i]</div></pre></td></tr></table></figure><h3 id="测试报告生成">测试报告生成</h3><p>由于没有简单的重定向方法，新增加一个报告生成的方式需要大量重复代码，所以只完成了标准输出的方式。</p><p>报告分为三个部分： 1. 测试总体概览，包括测试的时间、参数等等； 2. 时间分段的响应时间统计； 3. 测试进程的响应时间统计；</p><p>输出部分的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">"\n===Summary==="</span></div><div class="line"><span class="keyword">print</span> <span class="string">"transactions: %d hits"</span> % (queue_reader.trans_count)</div><div class="line"><span class="keyword">print</span> <span class="string">"errors: %d"</span> % (queue_reader.error_count)</div><div class="line"><span class="keyword">print</span> <span class="string">"runtime: %d secs"</span> % (test_duration)</div><div class="line"><span class="keyword">print</span> <span class="string">"rampup: %d secs"</span> % (int(args.get(<span class="string">'r'</span>)))</div><div class="line"><span class="keyword">print</span> <span class="string">"time-series interval: %0.3f secs"</span> % (interval_time)</div><div class="line"><span class="keyword">print</span> <span class="string">""</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"test start: %s"</span> % (datetime.fromtimestamp(test_start_timestamp).strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</div><div class="line"><span class="keyword">print</span> <span class="string">"test finish: %s"</span> % (datetime.fromtimestamp(test_end_timestamp).strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</div><div class="line"><span class="keyword">print</span> <span class="string">"\n===All Transactions==="</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Response Time Summary (secs):"</span></div><div class="line"><span class="keyword">print</span> <span class="string">"%7s\t%7s\t%7s\t%7s\t%7s\t%7s\t%7s\t%7s"</span> % (<span class="string">"count"</span>, <span class="string">"avg"</span>, <span class="string">"min"</span>, <span class="string">"50pct"</span>, <span class="string">"80pct"</span>, <span class="string">"90pct"</span>, <span class="string">"max"</span>, <span class="string">"stdev"</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"%7d\t%7.3f\t%7.3f\t%7.3f\t%7.3f\t%7.3f\t%7.3f\t%7.3f\n"</span> % (len(all_run_time), average(all_run_time), minarg(all_run_time), percentile(all_run_time, <span class="number">50</span>),\</div><div class="line"> percentile(all_run_time, <span class="number">80</span>), percentile(all_run_time, <span class="number">90</span>), maxarg(all_run_time), standard_dev(all_run_time))</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Interval Details (secs):"</span></div><div class="line"><span class="keyword">print</span> <span class="string">"%8s\t%7s\t%7s\t%7s\t%7s\t%7s\t%7s\t%7s\t%7s"</span> % (<span class="string">"interval"</span>, <span class="string">"count"</span>, <span class="string">"avg"</span>, <span class="string">"min"</span>, <span class="string">"50pct"</span>, <span class="string">"80pct"</span>, <span class="string">"90pct"</span>, <span class="string">"max"</span>, <span class="string">"stdev"</span>)</div><div class="line"><span class="keyword">for</span> interval_num <span class="keyword">in</span> range(interval):</div><div class="line">    interval_list = interval_run_time[interval_num]</div><div class="line">    <span class="keyword">print</span> <span class="string">"%8d\t%7d\t%7.3f\t%7.3f\t%7.3f\t%7.3f\t%7.3f\t%7.3f\t%7.3f"</span> % (interval_num, len(interval_list), average(interval_list), minarg(interval_list), percentile(interval_list, <span class="number">50</span>),\</div><div class="line"> percentile(interval_list, <span class="number">80</span>), percentile(interval_list, <span class="number">90</span>), maxarg(interval_list), standard_dev(interval_list))</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"\n===Agent Details==="</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Agent\tStarttime\tRequests\tErrors\tBytes received\tAvg Response Time(secs)\tAvg throughput(req/sec)"</span></div><div class="line"><span class="keyword">for</span> agent_detail <span class="keyword">in</span> ag.details:</div><div class="line">    <span class="keyword">print</span> agent_detail</div></pre></td></tr></table></figure><h2 id="性能优化和提速">性能优化和提速</h2><p><code>Python</code>本身的效率不是很高，这一点有可能会对测试结果产生影响。另外，由于默认的<code>Python</code>解释器存在<code>GIL</code>的问题，在多线程的情况下会出现严重的性能问题。所以需要一些方法来提高整个测试程序的运行速度。</p><p>需要注意的是，默认的测试代码比较简单，对计算能力要求不高，属于<code>IO密集型</code>的任务，任务的瓶颈在于网速，所以要求不高时，默认的<code>Python</code>完全能够胜任。</p><h3 id="采用pypy提速">采用PyPy提速</h3><p><code>PyPy</code>是一个独立的解析器， 通过即时编译(JIT,Just-in-time)代码避免逐行解释执行来提升运行速度。由于我们的项目采用纯<code>Python</code>编写实现，所以可以简单的通过替换使用<code>PyPy</code>的解释器来达到提速的效果。</p><p>首先下载最新版本的<code>PyPy</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://bitbucket.org/pypy/pypy/downloads/pypy2-v5.3.1-linux64.tar.bz2</div></pre></td></tr></table></figure><p>解压后，用新的解释器来执行程序即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/path/to/pypy/bin/pypy main.py -h</div></pre></td></tr></table></figure><p>但是这样仍然存在<code>GIL</code>的问题，可以通过使用<code>pypy-stm</code>版本来解决这个问题，安装和使用的方法与普通版的一样。</p><h3 id="不同版本的解释器测试结果比较">不同版本的解释器测试结果比较</h3><p>测试目标网站还是<code>www.baidu.com</code>。测试参数为20个并发进程，持续30秒，无启动时间。统计分为10段。测试使用的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ python main.py -a 20 -d 30 -i 10 -u http://www.baidu.com</div><div class="line">$ pypy-stm/bin/pypy-stm main.py  -a 20 -d 30 -i 10 -u http://www.baidu.com</div><div class="line">$ pypy/bin/pypy main.py  -a 10 -d 30 -i 10 -u http://www.baidu.com</div></pre></td></tr></table></figure><p>在测试时间内，三个版本分别完成的请求数为1938，2033，1828次。</p><p>三个版本相差不多，而且由于测试时间较短，而新建进程开销较大，所以<code>pypy</code>的速度甚至慢于原版<code>Python</code>，而<code>pypy-stm</code>版本速度最快。</p><h2 id="存在的问题">存在的问题</h2><p>这个程序在我的<code>Macbook pro</code>上的结果比较奇怪，当进程数增加时，平均响应时间会显著减少，多次测试和分析之后发现应该是性能原因导致的，但是系统资源并没有被完全利用。而同样的代码在阿里云的<code>Ubuntu</code>服务器上运行正常，猜测是由于系统的多进程API差异导致的。目前没有发现解决方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目介绍&quot;&gt;项目介绍&lt;/h2&gt;&lt;p&gt;pyWebTest是一个性能和负载测试工具，采用纯python编写，可以并发地对目标网站生成请求，测试响应时间和吞吐量，并生成完整的测试报告。&lt;/p&gt;&lt;p&gt;通过简单地修改测试部分的代码，可以很快的实现对远程API的压力测试，事实
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.mkdef.com/tags/Python/"/>
    
      <category term="Thread" scheme="http://blog.mkdef.com/tags/Thread/"/>
    
      <category term="PyPy" scheme="http://blog.mkdef.com/tags/PyPy/"/>
    
  </entry>
  
  <entry>
    <title>Odes（二）页面设计与实现</title>
    <link href="http://blog.mkdef.com/2016/06/20/Odes%EF%BC%88%E4%BA%8C%EF%BC%89%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.mkdef.com/2016/06/20/Odes（二）页面设计与实现/</id>
    <published>2016-06-20T05:46:52.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体结构">整体结构</h2><p>网站按照之前在Everstring常用的前后端结构，后端只提供api，前端一个html从后端请求数据然后展示，用nginx讲两者的流量区分开来。本来前端需要<code>gulp</code>配置一通流水线工具的，但是折腾了一天也没有弄出个样子来，干脆放弃这些高端玩意，先把东西用最原始最简单的方法做出来，有需求了才有动力换新的方法。</p><h2 id="后端实现">后端实现</h2><p>由于目前只有一个展示诗文正文的一个页面，所以api非常简单。一开始的版本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@app.route("/odes-api/&lt;int:id&gt;")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ode_by_id</span><span class="params">(id)</span>:</span></div><div class="line">	script = <span class="string">"""</span></div><div class="line">		WITH s AS (SELECT * FROM odes where id = %s) SELECT row_to_json(s) FROM s;</div><div class="line">	"""</div><div class="line">	cu.execute(script, (id,))</div><div class="line">	res = cu.fetchall()</div><div class="line">	<span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">		<span class="keyword">raise</span> ValueError</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> jsonify(res[<span class="number">0</span>])</div></pre></td></tr></table></figure><p>请求一个id的数据，把对应诗文的内容和相关的一些数据全部传输过去。这里错误处理暂时没有实现。</p><p>后来为了实现上一篇和下一篇的功能，考虑了一番决定还是通过这一个api把相邻两个诗文的数据一并传输过去，对应的sql语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WITH s AS (SELECT * FROM odes where id in (%s, %s, %s)) SELECT array_to_json(array_agg(row_to_json(s))) FROM s;</div></pre></td></tr></table></figure><p>这样一来，问题就在于前端如何知道哪个数据是自己的，哪个数据是相邻页面的，于是手工调整顺序，将请求的数据放在中间。于是丑陋的代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (id == <span class="number">1</span>):</div><div class="line">	res[<span class="number">0</span>][<span class="number">0</span>], res[<span class="number">0</span>][<span class="number">1</span>], res[<span class="number">0</span>][<span class="number">2</span>] = res[<span class="number">0</span>][<span class="number">2</span>], res[<span class="number">0</span>][<span class="number">0</span>], res[<span class="number">0</span>][<span class="number">1</span>]</div><div class="line"><span class="keyword">if</span> (id == MAXID):</div><div class="line">	res[<span class="number">0</span>][<span class="number">0</span>], res[<span class="number">0</span>][<span class="number">1</span>], res[<span class="number">0</span>][<span class="number">2</span>] = res[<span class="number">0</span>][<span class="number">1</span>], res[<span class="number">0</span>][<span class="number">2</span>], res[<span class="number">0</span>][<span class="number">0</span>]</div></pre></td></tr></table></figure><p>但是这样会出现几个问题，第一个是顺序是由postgres默认决定的，程序没有做校验，也没有办法校验（各个数据一致，没有字段标识区别开），正确结果依赖于各个部分默契合作，这样显然是不合理的。第二个是传输查询的内容过多，然而很多信息是毫无必要的，减慢了页面的加载速度。所以重新设计如下：第一，不采用循环的方式，第一篇没有上一篇，最后一篇没有下一篇(一方面处理逻辑要简单很多，更主要的是这个功能确实无所谓)。第二，分两次查询，因为查询是在服务器本地进行的，查询两次代价并不大，第二次仅仅查询相邻篇章的标题。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WITH s AS (SELECT title FROM odes where id in (%s, %s)) SELECT array_to_json(array_agg(row_to_json(s))) FROM s;</div></pre></td></tr></table></figure><p>然后把结果插入到请求的数据中去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res[<span class="number">0</span>][<span class="string">"pre_title"</span>] = navi[<span class="number">0</span>][<span class="number">0</span>].get(<span class="string">'title'</span>) <span class="keyword">if</span> id &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">None</span></div><div class="line">res[<span class="number">0</span>][<span class="string">"next_title"</span>] = navi[<span class="number">0</span>][<span class="number">-1</span>].get(<span class="string">'title'</span>) <span class="keyword">if</span> id &lt; MAXID <span class="keyword">else</span> <span class="keyword">None</span></div></pre></td></tr></table></figure><p>其中<code>res</code>是第一次查询的结果，<code>navi</code>是第二次查询的结果。这样就显式的声明了前后文的标题，也就不会出现顺序的错误了，而且大大减少了传输的数据。</p><h2 id="前端实现">前端实现</h2><p>目前只实现了原文的展示功能，整个页面分为如下几个部分：</p><pre><code>1. 顶部导航条，导航条目前有两个部分：左上角的Brand和右上角的随机浏览按钮。之后左上角还想加上搜索框。
2. 上下翻页栏。
3. 目录结构显示，这个功能实现了，但是不知道放在哪里比较好看，所以被我注释掉了。
4. 标题和正文。</code></pre><h3 id="顶部导航条">顶部导航条</h3><p>html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-default navbar-fixed-top"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"brand"</span> <span class="attr">src</span>=<span class="string">"favicon.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> </div><div class="line">           <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav navbar-right"</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"random_ode"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"btn-lg"</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-random"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div></pre></td></tr></table></figure><p>就是bootstrap的默认组件而已，稍微值得一提的是随机数的产生：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x) + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>应该是可以产生1到x之间的任意整数的，包括x。</p><h3 id="上下翻页">上下翻页</h3><p>就是两个简单的超链接，一个推到左上角，一个推到右上角。左右的篇章id通过api请求得到，这个之前已经提到过。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"navigate"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'pull-left'</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"left_ode"</span> <span class="attr">class</span>=<span class="string">"navigate"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"pull-right"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"right_ode"</span> <span class="attr">class</span>=<span class="string">"navigate"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="正文部分">正文部分</h3><p>正文部分分为标题和内容两个部分，值得一提的<code>css</code>部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ode"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"fulltext"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>由于我觉得诗经这种长短参差不齐的诗句，全部左对齐会好看一些，但是又希望标题能够居中，并且和正文对齐。所以需要它的宽度和内容自适应。解决方法是将它设置为<code>inline-block</code>。 另外，在上传时，内容中就包含了换行符，以此来保证诗文显示出来的格式正确(为了限制长度，手工调整过一次，不过调整得非常不仔细，所以可能会出现内容连贯，但是被我强行换行的情况。)，所以需要能够自动显示出换行符。解决方法是<code>pre</code>。 于是，完整的css设置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#ode&#123;</div><div class="line">	text-align: center;</div><div class="line">	font-family: Helvetica, Tahoma, Arial, STXihei, "华文细黑", "Microsoft YaHei", "微软雅黑", SimSun, "宋体", Heiti, "黑体", sans-serif;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#title&#123;</div><div class="line">	font-size: 3.5em;</div><div class="line">	margin: 5% auto;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#fulltext&#123;</div><div class="line">	font-size: 2.5em;</div><div class="line">	margin: auto;</div><div class="line">	text-align: left;</div><div class="line">	white-space:pre;</div><div class="line">	display:inline-block; </div><div class="line">	*display:inline; </div><div class="line">	*zoom:1; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="部分javascript功能代码">部分JavaScript功能代码</h2><h3 id="获取页面参数">获取页面参数</h3><p>由于浏览器得到的只是一个html文件，所以它得不到请求的参数，需要从<code>url</code>手工解析出来。解析的<code>javascript</code>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getUrlParameter = <span class="function"><span class="keyword">function</span> <span class="title">getUrlParameter</span>(<span class="params">sParam</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sPageURL = <span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>.location.search.substring(<span class="number">1</span>)),</div><div class="line">        sURLVariables = sPageURL.split(<span class="string">'&amp;'</span>),</div><div class="line">        sParameterName,</div><div class="line">        i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sURLVariables.length; i++) &#123;</div><div class="line">        sParameterName = sURLVariables[i].split(<span class="string">'='</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (sParameterName[<span class="number">0</span>] === sParam) &#123;</div><div class="line">            <span class="keyword">return</span> sParameterName[<span class="number">1</span>] === <span class="literal">undefined</span> ? <span class="literal">true</span> : sParameterName[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">page_id = getUrlParameter(<span class="string">'id'</span>);</div><div class="line"><span class="keyword">if</span> (!page_id) &#123;</div><div class="line">	page_id = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面的一小段代码是如果没有解析到参数，默认显示第一篇，这样就可以通过最简单的域名访问到网站了：<a href="http://odes.mkdef.com" target="_blank" rel="external">odes.mkdef.com</a></p><h3 id="字符串替换">字符串替换</h3><p>由于<code>lodash</code>使用的时候需要一些额外的工作，为了简单抄了一段实现字符串替换功能的代码，效果不错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.prototype.replaceAll = <span class="function"><span class="keyword">function</span>(<span class="params">search, replacement</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> target.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(search, <span class="string">'g'</span>), replacement);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="小结">小结</h2><p>我写前端的经验真的非常匮乏，所以这些实现仅仅保证了看起来是设想的那样子，至于是不是最优，会不会有其他潜在的缺点就不得而知了，至少目前还没有暴露出来。这篇文章仅仅当作给自己的一份前端笔记好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整体结构&quot;&gt;整体结构&lt;/h2&gt;&lt;p&gt;网站按照之前在Everstring常用的前后端结构，后端只提供api，前端一个html从后端请求数据然后展示，用nginx讲两者的流量区分开来。本来前端需要&lt;code&gt;gulp&lt;/code&gt;配置一通流水线工具的，但是折腾了一天也
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.mkdef.com/tags/Python/"/>
    
      <category term="诗经" scheme="http://blog.mkdef.com/tags/%E8%AF%97%E7%BB%8F/"/>
    
      <category term="html" scheme="http://blog.mkdef.com/tags/html/"/>
    
      <category term="bootstrap" scheme="http://blog.mkdef.com/tags/bootstrap/"/>
    
      <category term="Javascript" scheme="http://blog.mkdef.com/tags/Javascript/"/>
    
      <category term="Jquery" scheme="http://blog.mkdef.com/tags/Jquery/"/>
    
      <category term="CSS" scheme="http://blog.mkdef.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Odes（一）爬取全文</title>
    <link href="http://blog.mkdef.com/2016/06/16/Odes%EF%BC%88%E4%B8%80%EF%BC%89%E7%88%AC%E5%8F%96%E5%85%A8%E6%96%87/"/>
    <id>http://blog.mkdef.com/2016/06/16/Odes（一）爬取全文/</id>
    <published>2016-06-16T02:02:25.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目想法">项目想法</h2><p>因为一直没有一个比较完整的项目，所以想参考<a href="http://zhangwenli.com/biangua/" target="_blank" rel="external">变卦</a>做一个小的project，展示一个内容有限但是比较有意思的东西，顺便学习实践一下前端技术，于是就选择了诗经。内容不多，一共也就305首。一共分成3个步骤吧，第一步找个网站抓一个比较完整的全文下来，整理好之后存放到数据库里，第二步写一个前端把内容展示出来，但是这边是前后端配合还是单独一个前端页面还没有想好。第三步是其他功能的加入，比如注音和释义，甚至其他的一些比如统计数据之类的功能。</p><p>时间安排上并没有计划，主要最近空闲时间比较多，又不想复习，于是才想做这么个项目。反正先把坑挖在这，什么时候能做完就只能随缘了。</p><h2 id="postgres安装和配置">postgres安装和配置</h2><p>其实这一部并不一定需要，因为内容确实不多，直接做成静态页面效果也不错。主要是为了之后第三部可能会需要比较复杂的功能时提前准备。但是没想到这一部花了比较多的时间，最后也只是能用，并没有设置成一个正常的状态。</p><h3 id="postgres安装">postgres安装</h3><p>按照各类教程中的内容，只需要这一步就可以安装好数据库并且自动开启服务，端口5432。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install postgresql</div></pre></td></tr></table></figure><p>但是执行完之后，psql并没有连上数据库，服务器上也看不到postgres的进程。</p><p>略去中间大量的搜索和尝试的过程，在<code>/usr/lib/postgresql/9.1/bin/</code>目录里找到常用的命令，于是按照手动启动数据库的方式启动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/lib/postgresql/9.1/bin/postgres -D ~/data</div></pre></td></tr></table></figure><p>这里提示我不能用root权限开启服务，恍然大悟，之前没有成功启动的原因可能就是因为我一直使用的root用户(使用的服务器虽然用了很长一段时间了，但是当时仅仅安装了一个wordpress就没有登上去过了。所以一直都是root用户。)但是它为什么没有任何提示呢？！于是得到一个教训，新服务器第一件事就是建立一个新的非root用户。建了一个新的用户<code>saukymo</code>之后，终于成功开启了服务。</p><p>之后的过程由于大量试错，现在不能准确回忆起来了，不过应该还是通过这个目录下的<code>initdb</code>和<code>createdb</code>成功建立了一个数据库<code>odes</code>。</p><p>在Mac中，可以通过<code>brew</code>安装，安装完成之后就可以使用<code>psql</code>了，之后也能安装<code>psycopg2</code>的python库了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install postgresql</div></pre></td></tr></table></figure><p>直接使用<code>psql</code>命令进入数据库，然后给用户设置密码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\password saukymo</div></pre></td></tr></table></figure><h3 id="postgres允许远程连接">Postgres允许远程连接</h3><p>默认情况下，只允许本机连接数据库，如果需要远程连接到数据库，需要设置postgres允许远程连接。设置比较简单，首先修改<code>data</code>目录下的<code>pg_hba.conf</code>文件，加入一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">host    all             all             0.0.0.0/0               md5</div></pre></td></tr></table></figure><p>这样就能允许所有的ip通过密码访问数据库了。</p><p>然后修改<code>postgresl.conf</code>文件，设置<code>listen_addresses</code>为任意即可，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">listen_addresses = &apos;*&apos;</div></pre></td></tr></table></figure><p>然后重启服务，我这里因为安装方式不太正确，命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/lib/postgresql/9.1/bin/pg_ctl -D ~/data restart</div></pre></td></tr></table></figure><p>此时就能在其他机器上连接上数据库了，完整的<code>psql</code>命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">psql -U saukymo -h ▇▇.▇▇.▇▇.▇▇ <span class="_">-d</span> odes -W</div></pre></td></tr></table></figure><p>按照提示输入之前设置的密码即可。</p><h3 id="安装psycopg2">安装psycopg2</h3><p>这个库是python用来连接<code>postgres</code>数据库的，通过<code>pip</code>安装即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install psycopg2</div></pre></td></tr></table></figure><p>需要注意的是，这个库并不能兼容<code>Pypy</code>，如果需要和<code>Pypy</code>一起工作的话，需要安装<a href="https://pypi.python.org/pypi/psycopg2cffi" target="_blank" rel="external">psycopg2cffi</a>，简单设置之后，就可以兼容了，而且原来的代码不需要变化。</p><p>可以用以下代码进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding: utf-8</span></div><div class="line"><span class="keyword">import</span> psycopg2 <span class="keyword">as</span> pg</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    db = pg.connect(database=<span class="string">"odes"</span>, user=<span class="string">"saukymo"</span>, password=<span class="string">"▇▇▇▇▇▇▇▇"</span>, host=<span class="string">"▇▇.▇▇.▇▇.▇▇"</span>, port=<span class="string">"5432"</span>)</div></pre></td></tr></table></figure><h2 id="爬取诗经全文">爬取诗经全文</h2><p>需要的库比较少，除了<code>psycopg2</code>，另外就是<code>lxml</code>用来解析HTML，其他的库暂时都不需要了。安装方法都是通过<code>pip</code>。</p><p>目标网页一开始选择的是<a href="http://www.shigeku.com/xlib/gd/sj305/" target="_blank" rel="external">诗歌库</a>，因为发现结构挺简单的，好像也比较完整和规范。所以还比较顺利地抓完了目录和第一篇正文，但是开始全文抓取的时候，第二篇就编码错误了。本来也没多想，编码错误再正常不过了，于是尝试了多个不同的中文编码，全部报错，<code>ISO</code>虽然能解析完，但是解析出来的都是看不懂的蚂蚁文。</p><p>看了一下网页编码，<code>GB2312</code>，应该没有问题呀，但是解析不对。安装了<code>chardet</code>探测，发现出错的页面里，虽然主要是’gb2312’，但是置信度确实不高，反复检查之后发现，原来是原文中本来就存在解析不了乱码，显示成了方框。</p><p>思考了一番，没有什么好的方法，只好换抓另一个网页：<a href="http://www.zwbk.org/MyLemmaShow.aspx?lid=76385" target="_blank" rel="external">中文百科在线</a>，简单看了一下，还不错，目录简单，结构还比较规范，于是就开始抓了，结果发现所谓的规范，仅仅是看上去而已。</p><h3 id="爬取目录">爬取目录</h3><p>目录爬取比较简单，全部代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">url = <span class="string">"http://www.zwbk.org/MyLemmaShow.aspx?lid=76385"</span></div><div class="line">connect = urlopen(url)</div><div class="line"></div><div class="line">content = connect.read()</div><div class="line">page = html.parse(StringIO(content.decode(<span class="string">'utf-8'</span>)))</div><div class="line">table = page.xpath(<span class="string">"//table/tr/td[2]/div/div[7]"</span>)</div><div class="line"></div><div class="line">collect_list = []</div><div class="line"><span class="keyword">for</span> links <span class="keyword">in</span> table[<span class="number">0</span>].find_class(<span class="string">"classic"</span>):</div><div class="line">	title = links.text_content().split(<span class="string">u"·"</span>)</div><div class="line">	<span class="keyword">if</span> len(title) &gt; <span class="number">3</span>:</div><div class="line">		page_url = links.attrib.get(<span class="string">"href"</span>)</div><div class="line">		collect_list.append(&#123;</div><div class="line">			<span class="string">"category"</span>: title[<span class="number">1</span>],</div><div class="line">			<span class="string">"collect"</span>: title[<span class="number">2</span>],</div><div class="line">			<span class="string">"title"</span>: title[<span class="number">3</span>],</div><div class="line">			<span class="string">"page_url"</span>: page_url</div><div class="line">			&#125;)</div></pre></td></tr></table></figure><p>因为网站给这些目录全部加上了<code>classic</code>类，所以先用<code>xpath</code>找到具体的代码块，然后在其中找<code>classic</code>类即可。</p><p>然后通过map来批量抓取全部正文：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = map(<span class="keyword">lambda</span> x: get_fulltext(**x), collect_list)</div></pre></td></tr></table></figure><h3 id="爬取正文">爬取正文</h3><p>正文部分就比较麻烦了，首先内容不是被单独封装在一起的，而是被各种<code>h2</code>,<code>br</code>等标签分隔开了，所以提取比较麻烦，正好同学之前问了相同的问题，当时没有给出好的解决方法，这次搜索了一下发现，<code>lxml</code>提供了<code>tail</code>方法，可以得到两个子元素之间的内容，于是比较好的解决了这个问题。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fulltext</span><span class="params">(category, collect, title, page_url)</span>:</span></div><div class="line">	<span class="keyword">print</span> category, collect, title</div><div class="line">	<span class="keyword">try</span>:</div><div class="line">		content = urlopen(page_url).read()</div><div class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">		<span class="keyword">print</span> e</div><div class="line">		<span class="keyword">return</span> &#123;<span class="string">"title"</span>:<span class="string">"%s_%s_%s"</span> % (category, collect, title), <span class="string">"text"</span>:<span class="string">""</span>&#125;</div><div class="line">		</div><div class="line">	page = html.parse(StringIO(content.decode(<span class="string">'utf-8'</span>)))</div><div class="line">	table = page.xpath(<span class="string">'//td[2]/div/div[7]'</span>)</div><div class="line">	<span class="keyword">if</span> len(table) &gt; <span class="number">0</span>:</div><div class="line">		odes = table[<span class="number">0</span>]</div><div class="line">		skip_state = <span class="number">0</span></div><div class="line">		full_text = []</div><div class="line">		<span class="keyword">for</span> element <span class="keyword">in</span> odes.getchildren():</div><div class="line">			text = <span class="string">""</span></div><div class="line">			<span class="keyword">if</span> element.tag <span class="keyword">is</span> etree.Comment:</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			<span class="keyword">if</span> element.tag == <span class="string">"h2"</span>:</div><div class="line">				skip_state += <span class="number">1</span></div><div class="line">			<span class="keyword">if</span> (element.tag == <span class="string">"div"</span>) <span class="keyword">and</span> skip_state == <span class="number">1</span>:</div><div class="line">				text = element.text_content().strip()</div><div class="line">			<span class="keyword">if</span> (element.tag == <span class="string">"br"</span>) <span class="keyword">and</span> skip_state == <span class="number">1</span>:</div><div class="line">				<span class="keyword">if</span> element.tail <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">					text = element.tail.strip()</div><div class="line">			<span class="keyword">if</span> text != <span class="string">""</span>:</div><div class="line">				full_text.append(text)</div><div class="line">	<span class="keyword">return</span> &#123;<span class="string">"title"</span>:<span class="string">"%s_%s_%s"</span> % (category, collect, title), <span class="string">"text"</span>:full_text&#125;</div></pre></td></tr></table></figure><p>大意是提取第一个<code>h2</code>和第二个<code>h2</code>之间的所有内容。比较顺利的得到了大部分正文。有如下几个问题和我采用的解决方法(好像全都是手动完善的…)</p><pre><code>1. 鹊巢这一篇抓不到正文内容，原因不详，不过只有这一篇，所以手工补全；
2. 有的正文混入了注释，手工删除；  
3. 抓一部分之后，会出现连续的503错误，猜测网站做了防抓取或者平时访问没有这么频繁，短时间内挂掉了。多抓几次，手工拼合。
4. 这个网站，颂部分少了很多篇，比如清庙之什应该是10篇的，它只有一篇，所以手工从诗歌库上复制粘贴过来，然后替换成相同格式。
5. 有的篇章没有换行，或者有多余空格，手工清除。
6. 保存的文本用python读取不出来，原因不详。用`Sublime Text`打开，复制粘贴到新的文件，一切正常。</code></pre><p>秉承的唯一信念就是，反正只有300篇，也是一次性的工作，做完就可以了。所以手工修复了所有的bug，目前看上去效果良好。</p><h2 id="上传数据库">上传数据库</h2><h3 id="建表">建表</h3><p>一共就一个表，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE IF NOT EXISTS odes (</div><div class="line">       id SERIAL PRIMARY KEY,</div><div class="line">       p_class TEXT,</div><div class="line">       p_group TEXT,</div><div class="line">       p_subgroup TEXT,</div><div class="line">       title TEXT,</div><div class="line">       full_text TEXT,</div><div class="line">       create_time TIMESTAMP,</div><div class="line">       update_time TIMESTAMP</div></pre></td></tr></table></figure><p>其中，<code>p_class</code>是指风雅颂三类，<code>p_group</code>是细分，比如<code>周南</code>,<code>召南</code>。<code>p_subgroup</code>指的是什。其他看名字就知道了。 另外 <code>SERIAL</code>是自增序列，<code>postgres</code>会自动新建一个自增的序列作为它的值。当然也可以手工建立，然后链接过来。</p><h3 id="设置触发器">设置触发器</h3><p>然后为创建和更新时间设置触发器自动更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE OR REPLACE FUNCTION auto_timestamp() RETURNS trigger AS $auto_timestamp$</div><div class="line">       BEGIN</div><div class="line">       IF (TG_OP = &apos;INSERT&apos;) THEN</div><div class="line">               NEW.create_time := current_timestamp;</div><div class="line">          NEW.update_time := current_timestamp;</div><div class="line">       ELSIF (TG_OP = &apos;UPDATE&apos;) THEN</div><div class="line">         NEW.update_time := current_timestamp;</div><div class="line">       END IF;</div><div class="line">           RETURN NEW;</div><div class="line">       END;</div><div class="line">       $auto_timestamp$ LANGUAGE plpgsql;</div><div class="line"></div><div class="line">   DROP TRIGGER IF EXISTS auto_timestamp ON odes;</div><div class="line">   CREATE TRIGGER auto_timestamp BEFORE INSERT OR UPDATE ON odes</div><div class="line">       FOR EACH ROW EXECUTE PROCEDURE auto_timestamp();</div></pre></td></tr></table></figure><h3 id="上传">上传</h3><p>具体解析就不写了，因为保存的格式是我自定义的。上传部分的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_one_ode</span><span class="params">(metadata)</span>:</span></div><div class="line">    script = <span class="string">"""</span></div><div class="line">        INSERT INTO odes (p_class, p_group, p_subgroup, title, full_text) </div><div class="line">            VALUES (%(p_class)s, %(p_group)s, %(p_subgroup)s, %(title)s, %(full_text)s);</div><div class="line">    """</div><div class="line">    cu.execute(script, metadata)</div></pre></td></tr></table></figure><p>最后记得<code>commit</code>就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.commit()</div></pre></td></tr></table></figure><h3 id="在数据库中查看数据">在数据库中查看数据</h3><p>首先，连接到数据库中，看一下有多少条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">odes=# select count(*) from odes;</div><div class="line"> count</div><div class="line">-------</div><div class="line">   305</div><div class="line">(1 row)</div></pre></td></tr></table></figure><p>然后随便抽一条数据检查一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">odes=# select * from odes where id=180;</div><div class="line"> id  | p_class | p_group | p_subgroup | title |                          full_text                           |        create_time         |        update_time</div><div class="line">-----+---------+---------+------------+-------+--------------------------------------------------------------+----------------------------+----------------------------</div><div class="line"> 180 | 雅      | 小雅     | 彤弓之什    | 吉日   | 吉日维戊，既伯既祷。田车既好，四牡孔阜。升彼大阜，从其群丑。+| 2016-06-15 21:53:41.366594 | 2016-06-15 21:53:41.366594</div><div class="line">     |         |         |            |       | 吉日庚午，既差我马。兽之所同，麀鹿麌麌。漆沮之从，天子之所。+|                            |</div><div class="line">     |         |         |            |       | 瞻彼中原，其祁孔有。儦儦俟俟，或群或友。悉率左右，以燕天子。+|                            |</div><div class="line">     |         |         |            |       | 既张我弓，既挟我矢。发彼小豝，殪此大兕。以御宾客，且以酌醴。+|                            |</div><div class="line">     |         |         |            |       |                                                              |                            |</div><div class="line">(1 row)</div></pre></td></tr></table></figure><p>其中<code>+</code>应该是换行符，可以看到还是比较规整的。</p><h2 id="小结">小结</h2><p>本来是一个非常简单的任务，还是花了不少时间和精力，而且过程中很多问题都只是绕了过去，并没有真正解决。不过好在最后的结果还是很不错的。目前还有一个问题值得商榷，就是保存正文时，换行是我手工换的，之后显示出来不一定好看，所以是否可以考虑不保存换行符，之后动态的调整。不过这个问题之后还是修改的空间，可以之后再根据情况调整。</p><p>全文可以在<a href="https://github.com/saukymo/odes/blob/master/crawler/full_text.txt" target="_blank" rel="external">这里</a>下载到</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目想法&quot;&gt;项目想法&lt;/h2&gt;&lt;p&gt;因为一直没有一个比较完整的项目，所以想参考&lt;a href=&quot;http://zhangwenli.com/biangua/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;变卦&lt;/a&gt;做一个小的project，展示
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.mkdef.com/tags/Python/"/>
    
      <category term="诗经" scheme="http://blog.mkdef.com/tags/%E8%AF%97%E7%BB%8F/"/>
    
      <category term="爬虫" scheme="http://blog.mkdef.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="lxml" scheme="http://blog.mkdef.com/tags/lxml/"/>
    
      <category term="postgresql" scheme="http://blog.mkdef.com/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3 配置</title>
    <link href="http://blog.mkdef.com/2016/05/30/Sublime-Text3-%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.mkdef.com/2016/05/30/Sublime-Text3-配置/</id>
    <published>2016-05-30T07:37:48.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sublime-text3-介绍">Sublime Text3 介绍</h2><p><a href="https://www.sublimetext.com/" target="_blank" rel="external">Sublime Text3</a>是一款轻量级、跨平台的、拓展功能丰富的编辑器，使用python编写，自然也是用来写python的不二选择。然而，通过丰富强大的插件配置，ST也可以用于其他各种语言的编写。这里主要介绍我常使用的python和<code>Markdown</code>的配置。</p><h2 id="package-control">Package Control</h2><p>要想在ST上使用插件，最方便的方法就是通过<code>Package Control</code>来安装，不过我们首先得手工安装它本身。</p><p>安装文档可以参考官方的<a href="https://packagecontrol.io/installation" target="_blank" rel="external">主页</a>，使用<code>Ctrl+`</code>调出console，复制以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</div></pre></td></tr></table></figure><p>其实是压成一行的python代码，不过我还是不把它高亮了。安装完成之后，就可以通过<code>Ctrl+shift+P</code>来打开命令面板，然后在里面输入<code>install</code>，就能找到<code>install package</code>的选项，回车之后就能看到所有的插件列表了。</p><h2 id="主题美化">主题美化</h2><p>作为一个看脸的世界，肯定首先要把界面得漂漂亮亮的才会有动力继续用下。虽然说，ST本身的界面已经非常好看了，我自己也对着这个朴素的界面用了很多很多年。但是今天在<a href="https://dribbble.com/search?q=sublime" target="_blank" rel="external">dribbble</a>上看到了一个崭新的世界。不得不承认，程序员和设计师的审美差距还是有一定距离的。</p><p>最后采用的这个<a href="http://equinusocio.github.io/material-theme/" target="_blank" rel="external">Material theme</a>主题，并且添加了所有可选选项(我相信人家的审美每一个细节都比我做得好)。效果非常好，python的高亮看着略不舒服，换成<code>OceanicNext</code>会好很多。</p><p>根据项目主页上的图片来看，<code>Markdown</code>的配色应该是这个主题设置的，然而我在第一时间并没有看到效果，倒是反反复复折腾了很久的<code>Markdown</code>插件之后才突然正常了，不过只要设置正常了，效果非常非常赞。</p><h2 id="python插件配置">Python插件配置</h2><p>这里提到的插件，都是通过<code>Package Control</code>里直接输入名字就能安装的。</p><h3 id="sidebarfolders"><a href="https://github.com/titoBouzout/SideBarFolders" target="_blank" rel="external">SideBarFolders</a></h3><p>如果同时开发好几个项目时，ST打开项目文件夹比较麻烦，有了这个插件之后，菜单上就会多出一项<code>Folders</code>，里面就可以方便切换最近打开的目录，非常的方便。同时，如果文件夹位置发生了变动，导致之前的目录失效了，它也会提醒删除，也算是一个不错的处理方式(要求不要太高)。</p><h3 id="sublimerepl"><a href="https://github.com/wuub/SublimeREPL" target="_blank" rel="external">SublimeREPL</a></h3><p>之前很长一段时间里，在ST跑python程序都不能中止，让我很是郁闷，前几年从来没有这个问题啊。后来发现是因为有一次强迫症发作，只挑了自己认识的插件安装，结果落下了这个插件。事实上，正是这个插件默默的提供了一个内置的解释器来运行python程序，也只有这样，才能通过快捷键中止程序。目前看来，对于终端的交互支持得不是很好，不过平时开发的时候，也不会用到终端输入了吧..</p><h3 id="sidebarenhancements"><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">SideBarEnhancements</a></h3><p>侧边文件栏功能加强的插件，虽然说实话我并没有仔细对比过多了哪些功能，因为之前的功能我也用得不多。不过直观上感觉右键菜单确实长了好多，之后会多多关注一下。</p><h3 id="sublimecodeintel"><a href="https://github.com/SublimeCodeIntel/SublimeCodeIntel" target="_blank" rel="external">SublimeCodeIntel</a></h3><p>支持很多语言的自动补全提醒，再也不用dir一个一个看了。提示非常高大上，不过如果记错了函数位置，然后找半天找不到还是比较尴尬的(怪我咯)</p><h3 id="virtuallenv"><a href="https://github.com/AdrianLC/sublime-text-virtualenv" target="_blank" rel="external">Virtuallenv</a></h3><p>可以很方便的激活虚拟环境，事实上我也就用过这一个功能..其他管理的功能应该也都有，但是没有用过。不过发现这个插件和<code>SublimeREPL</code>不能一起使用，也就是说用那个插件不能按照我目前的习惯使用<code>virtualenv</code>，用这个插件的话就不能中止程序了。Anyway, 这个坑还得多试试，目前看来这个插件估计用得不会太多。</p><h3 id="sublimegit"><a href="https://github.com/SublimeGit/SublimeGit" target="_blank" rel="external">SublimeGit</a></h3><p>洛洛推荐的Git集成，大部分时候都非常好用，除了本地merge出现冲突的时候出现过Bug，当然也有可能是打开方式不太对。之后自己的项目基本也都用Github管理了，所以这个插件应该会用得更多。</p><h2 id="markdown插件配置">Markdown插件配置</h2><h3 id="markdown-extended"><a href="https://github.com/jonschlinkert/sublime-markdown-extended" target="_blank" rel="external">Markdown Extended</a></h3><p>安装完之后，Syntax里会多出一个类型<code>Markdown Extended</code>，将<code>.md</code>的文件和这个新类型绑定起来之后，就能看到丰富的配色了。其实我不确定到底是这个插件的作用还是之前那个<code>Material theme</code>的作用才有了我现在的<code>Markdown</code>配色，总之很赞。</p><h3 id="omnimarkuppreviewer"><a href="https://github.com/timonwong/OmniMarkupPreviewer" target="_blank" rel="external">OmniMarkupPreviewer</a></h3><p>用来预览<code>Markdown</code>文件的，其实如果我只是为了写<code>Hexo</code>的话，直接用<code>Hexo</code>渲染预览就好了，效果更好。但是如果为了用在其他地方的话，这个插件还是不错的，而且它也支持其他格式的文件。</p><h2 id="小结">小结</h2><p><img src="/uploads/ST3.png"> 最后上一张王道，这样配置一番后，确实比之前的ST要好用很多(然而代码写得还是那么烂)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sublime-text3-介绍&quot;&gt;Sublime Text3 介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.sublimetext.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sublime Text3&lt;/a&gt;是一款
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.mkdef.com/tags/Python/"/>
    
      <category term="Sublime Text3" scheme="http://blog.mkdef.com/tags/Sublime-Text3/"/>
    
      <category term="Markdown" scheme="http://blog.mkdef.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>常微分方程-初等积分法</title>
    <link href="http://blog.mkdef.com/2016/05/28/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B-%E5%88%9D%E7%AD%89%E7%A7%AF%E5%88%86%E6%B3%95/"/>
    <id>http://blog.mkdef.com/2016/05/28/常微分方程-初等积分法/</id>
    <published>2016-05-28T11:58:35.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>由于复习系统优化理论，需要解常微分方程，然而数分早就还给<a href="http://www.math.sjtu.edu.cn/faculty/show.php?id=42" target="_blank" rel="external">陈克应老师</a>了，于是在询问老师之后，推荐我看这本书&lt;<常微分方程教程-丁同仁>&gt;，所以就整理了一下这部分笔记。</常微分方程教程-丁同仁></p><p>由于数学基础实在太差，所以忽略所有的细节条件，计算过程中也可能会有大量不严谨的地方，不纠结这些细节。</p><h2 id="恰当方程">恰当方程</h2><h3 id="定义">定义</h3><p>考虑如下形式的微分方程：</p><p><span class="math display">\[P(x,y) dx + Q(x,y)dy = 0\]</span></p><p>如果存在一个函数<span class="math inline">\(\phi (x, y)\)</span>满足：</p><p><span class="math display">\[d\phi(x, y) = P(x, y)dx + Q(x,y)dy\]</span></p><p>则称原微分方程为<strong>恰当方程</strong></p><p>那么就有3个问题：</p><ol style="list-style-type:decimal"><li>如何判定一个是不是恰当方程？</li><li>如果是，如何求解？</li><li>如果不是，能否转换？</li></ol><p>接下来的几节就是对这3个问题的回答。</p><h2 id="恰当方程的判定">恰当方程的判定</h2><p>充要条件如下：</p><p><span class="math display">\[\frac{\alpha P(x,y)}{\alpha y} = \frac{\alpha Q(x, y)}{\alpha x}\]</span></p><h2 id="恰当方程的求解">恰当方程的求解</h2><p>通解为：</p><p><span class="math display">\[\int^{x}_{x_{0}}P(x,y)dx + \int^{y}_{y_{0}}Q(x_{0}, y)dy = C\]</span></p><p>或者</p><p><span class="math display">\[\int^{x}_{x_{0}}P(x,y_{0})dx + \int^{y}_{y_{0}}Q(x, y)dy = C\]</span></p><p>剩下的小结是几类特殊形式的方程转换为恰当方程求解</p><h2 id="变量分离的方程">变量分离的方程</h2><p>如果方程具有以下形式：</p><p><span class="math display">\[X(x)Y_{1}(y) + X_{1}(x)Y(y)dy = 0\]</span></p><p>则可以等式两边同时除以<span class="math inline">\(X_{1}(x)Y_{1}(y)\)</span>，得到：</p><p><span class="math display">\[\frac{X(x)}{X_{1}(x)}dx + \frac{Y(y)}{Y_{1}(y)}dy = 0\]</span></p><p>因此，可以得到它的通解为：</p><p><span class="math display">\[\int\frac{X(x)}{X_{1}(x)}dx + \int\frac{Y(y)}{Y_{1}(y)}dy = C\]</span></p><p>除此之外，所有令<span class="math inline">\(X_{1}(x)Y_{1}(y) = 0\)</span>的解也都是原微分方程的解。</p><h2 id="一阶线性微分方程">一阶线性微分方程</h2><p>如果方程具有以下形式：</p><p><span class="math display">\[\frac{dy}{dx} + p(x)y = q(x)\]</span></p><p>若<span class="math inline">\(q(x) = 0\)</span>，则为<strong>齐次线性方程</strong>，否则为<strong>非齐次线性方程</strong></p><h3 id="齐次线性方程">齐次线性方程</h3><p><span class="math display">\[dy + p(x)ydx = 0\]</span></p><p>等式两边同时除以y，可得</p><p><span class="math display">\[\frac{1}{y}dy + p(x)dx = 0\]</span></p><p><span class="math display">\[y = Ce^{-\int p(x) dx}\]</span></p><h3 id="非齐次线性方程">非齐次线性方程</h3><p>等式两边同时乘以<span class="math inline">\(e^{\int p(x)dx}\)</span>得：</p><p><span class="math display">\[e^{\int p(x)dx}dy + e^{\int p(x)dx}p(x)ydx = e^{\int p(x)dx}q(x)dx\]</span></p><p><span class="math display">\[d(e^{\int p(x)dx}y) = d\int q(x) e^{\int p(x)dx} dx\]</span></p><p>解得</p><p><span class="math display">\[y = e^{-\int p(x)dx}(C + \int q(x) e^{\int p(x)dx}dx)\]</span></p><p>这个方法称为<strong>积分因子法</strong></p><h2 id="几个特殊的初等变换法">几个特殊的初等变换法</h2><h3 id="齐次方程不是齐次线性方程">齐次方程(不是齐次线性方程)</h3><p>若</p><p><span class="math display">\[P(x, y)dx + Q(x, y)dy = 0\]</span></p><p>中<span class="math inline">\(P(x, y), Q(x, y)\)</span>是<span class="math inline">\(x, y\)</span>的同次齐次函数，即：</p><p><span class="math display">\[P(tx, ty) = t^{m}P(x, y)\]</span></p><p><span class="math display">\[Q(tx, ty) = t^{m}Q(x, y)\]</span></p><p>令 <span class="math display">\[y = \mu x\]</span>， 则有：</p><p><span class="math display">\[P(x,y) = x^{m}P(1, \mu)\]</span></p><p><span class="math display">\[Q(x, y) = x^{m}Q(1, \mu)\]</span></p><p>原方程可化为：</p><p><span class="math display">\[x^{m}[P(1, \mu) + \mu Q(1, \mu)]dx + x^{m + 1}Q(1, \mu)d\mu = 0\]</span></p><p>这是一个变量分离方程。</p><h3 id="伯努利方程">伯努利方程</h3><p><span class="math display">\[\frac{dy}{dx} + p(x)y = q(x)y^{n}\]</span></p><p>两边同时乘以 <span class="math inline">\((1 - n)y^{-n}\)</span> 可得：</p><p><span class="math display">\[(1 - n) y^{-n}\frac{dy}{dx} + (1 - n)y^{-n}p(x)y = (1- n)y^{-n}q(x)y^{n}\]</span></p><p>令<span class="math inline">\(z = y^{-n}\)</span></p><p><span class="math display">\[\frac{dz}{dx} + (1 - n)p(x)z = (1-n)q(x)\]</span></p><p>这是关于<span class="math inline">\(z\)</span>的一阶线性方程</p><h3 id="里卡蒂方程">里卡蒂方程</h3><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;由于复习系统优化理论，需要解常微分方程，然而数分早就还给&lt;a href=&quot;http://www.math.sjtu.edu.cn/faculty/show.php?id=42&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
    
      <category term="常微分方程" scheme="http://blog.mkdef.com/tags/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>微信TCP行为分析</title>
    <link href="http://blog.mkdef.com/2016/05/19/%E5%BE%AE%E4%BF%A1TCP%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/"/>
    <id>http://blog.mkdef.com/2016/05/19/微信TCP行为分析/</id>
    <published>2016-05-19T06:36:48.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境设置">环境设置</h4><p>实验环境：</p><ol style="list-style-type:decimal"><li>iphone6 微信 WeChat6.3.16</li><li>macbook pro 分享wifi，网卡en0</li><li>wireshark 抓包，并存为Wireshark/tcpdump/…- pcap格式</li><li>tapo在osx中编译失败，所以采用上传数据到另一台ubuntu服务器中分析</li></ol><p>测试功能：</p><ol style="list-style-type:decimal"><li>聊天功能： 发送文字， 发送图片， 发送小视频；接收文字，接收图片，接收小视频。</li><li>朋友圈：发图文状态，发小视频；接收图文状态，接收小视频。</li></ol><p>抓包的结果记录如下：</p><table><colgroup><col width="13%"><col width="20%"><col width="20%"><col width="18%"><col width="25%"></colgroup><thead><tr class="header"><th>功能</th><th>发送者ip和端口</th><th>接收者ip和端口</th><th>TCP选项</th><th>文件名</th></tr></thead><tbody><tr class="odd"><td>发送文字</td><td>192.168.2.2.53671</td><td>223.167.105.117.443</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 459787696 ecr 0,sackOK,eol</td><td>wechat_send_text</td></tr><tr class="even"><td>发送图片</td><td>192.168.2.2.53673</td><td>125.39.132.125.443</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 458540380 ecr 0,sackOK,eol</td><td>wechat_send_picture</td></tr><tr class="odd"><td>发送小视频</td><td>192.168.2.2.53680</td><td>125.39.171.17.443</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 458953493 ecr 0,sackOK,eol</td><td>wechat_send_video</td></tr><tr class="even"><td>接收文字</td><td>223.167.105.117.443</td><td>192.168.2.2.53671</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 459286337 ecr 0,sackOK,eol</td><td>wechat_receive_text</td></tr><tr class="odd"><td>接收图片</td><td>125.39.132.125.443</td><td>192.168.2.2.53698</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 459286337 ecr 0,sackOK,eol</td><td>wechat_receive_picture</td></tr><tr class="even"><td>接收小视频</td><td>125.39.171.17.443</td><td>192.168.2.2.53764</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 460156224 ecr 0,sackOK,eol</td><td>wechat_receive_video</td></tr><tr class="odd"><td>朋友圈发图文</td><td>192.168.2.2.65283</td><td>123.151.79.111.8080</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 896590244 ecr 0,sackOK,eol</td><td>friend_cycle_picture</td></tr><tr class="even"><td>朋友圈发视频</td><td>192.168.2.2.65293</td><td>123.151.79.111.8080</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 896497923 ecr 0,sackOK,eol</td><td>friend_cycle_video</td></tr><tr class="odd"><td>朋友圈收图文</td><td>123.126.121.175.http</td><td>192.168.2.2.54055</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 896835785 ecr 0,sackOK,eol</td><td>friend_cycle_download_picture</td></tr><tr class="even"><td>朋友圈收视频</td><td>124.161.14.78.http</td><td>192.168.2.2.65378</td><td>mss 1460,nop,wscale 5,nop,nop,TS val 896835785 ecr 0,sackOK,eol</td><td>friend_cycle_download_video</td></tr></tbody></table><h4 id="tcpdump过滤脚本">tcpdump过滤脚本</h4><p>由于tapo分析时需要设置服务器ip，所以这里暂时只过滤出于测试机器相关的记录即可，测试机器的ip为192.168.2.2</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> f <span class="keyword">in</span> `ls pcap | grep pcap`</div><div class="line"><span class="keyword">do</span></div><div class="line">    name=<span class="variable">$&#123;f%.*&#125;</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$name</span>;</div><div class="line">    tcpdump -r pcap/<span class="variable">$name</span>.pcap host 192.168.2.2 &gt; txt/<span class="variable">$name</span>.info</div><div class="line">    tcpdump -r <span class="variable">$i</span> host 192.168.2.2 -w filter/<span class="variable">$i</span>.pcap</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><p>遍历所有pcap文件，用tcpdump过滤出与测试机器192.168.2.2有关的记录，存两份，一份以可阅读的形式存在txt目录下以便手工分析，一份仍然以pcap的格式存在filter目录下，用tapo分析。</p><h4 id="tapo分析">tapo分析</h4><p>根据上面抓包分析出的服务器ip和端口，生成分析脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">./tcp_tool  <span class="_">-f</span> pcap/friend_cycle_download_picture.pcap <span class="_">-s</span> 123.126.121.175 -p 80 -t down &gt; rst/friend_cycle_download_picture.txt</div><div class="line">./tcp_tool  <span class="_">-f</span> pcap/friend_cycle_download_video.pcap <span class="_">-s</span> 124.161.14.78 -p 80 -t down &gt; rst/friend_cycle_download_video.txt</div><div class="line">./tcp_tool  <span class="_">-f</span> pcap/friend_cycle_picture.pcap <span class="_">-s</span> 123.151.79.111 -p 8080 -t up &gt; rst/friend_cycle_picture.txt</div><div class="line">./tcp_tool  <span class="_">-f</span> pcap/friend_cycle_video.pcap <span class="_">-s</span> 123.151.79.111 -p 8080 -t up &gt; rst/friend_cycle_video.txt</div><div class="line">./tcp_tool  <span class="_">-f</span> pcap/wechat_receive_picture.pcap <span class="_">-s</span> 125.39.132.125 -p 443 -t down &gt; rst/wechat_receive_picture.txt</div><div class="line">./tcp_tool  <span class="_">-f</span> pcap/wechat_receive_text.pcap <span class="_">-s</span> 223.167.105.117 -p 443 -t down &gt; rst/wechat_receive_text.txt</div><div class="line">./tcp_tool  <span class="_">-f</span> pcap/wechat_receive_video.pcap <span class="_">-s</span> 125.39.171.17 -p 443 -t down &gt; rst/wechat_receive_video.txt</div><div class="line">./tcp_tool  <span class="_">-f</span> pcap/wechat_send_picture.pcap <span class="_">-s</span> 125.39.132.125 -p 443 -t up &gt; rst/wechat_send_picture.txt</div><div class="line">./tcp_tool  <span class="_">-f</span> pcap/wechat_send_text.pcap <span class="_">-s</span> 223.167.105.117 -p 443 -t up &gt; rst/wechat_send_text.txt</div><div class="line">./tcp_tool  <span class="_">-f</span> pcap/wechat_send_video.pcap <span class="_">-s</span> 125.39.171.17 -p 443 -t up &gt; rst/wechat_send_video.txt</div></pre></td></tr></table></figure><p>这里有一个小问题在于，发送和接收文本的pcap文件分析的结果为空，手工查看之后发现这两个功能的pcap文件与其他文件没有什么不用，只是采用了ssl协议加密，但是按照我的理解这应该不影响包序列的分析，所以原因不明。</p><h4 id="作图">作图</h4><p>使用tapo分析过后的结果作为作图的数据，需要注意的是，当文件中包含多个tcp链接时，tapo的结果会重新标记时间。这里采用累加的方法，将多个tcp连接绘制在同一张图上，所以真实的时间可能会缩短(多个tcp连接中间重叠)或延长(两个tcp连接中间有间隔)。</p><p>还有需要考虑的一点是，对于丢包的情况，tapo的结果中表现为乱序的sequence number，在图上表示就是一个下凹的曲线，我觉得这里应该采用接收端ack的序列作图更加合理。</p><p>作图采用plotly的python库, 这里只列出朋友圈发视频的sequence图和inflight_size图为例： <img src="/uploads/friend_cycle_post_video_sequence_number.png"> <img src="/uploads/friend_cycle_post_video_inflight_size.png"></p><p>其他的图可以在pic文件下找到。</p><h4 id="结果分析">结果分析</h4><p>对于收发文字这个功能，客户端与服务器只使用了一个tcp连接，当退出当前聊天窗口时会发送一个keep-alive，回到窗口时会继续采用这个tcp连接发送。这也可能是导致tapo不能正确的分析抓包数据的原因(没有捕获到tcp连接的建立和结束)</p><p>对于收发图片来说，是很明显的一张图片建立一个tcp连接；而小视频出现了一个tcp连接发送了两个小视频的情况。</p><p>文字、图片、视频都是不同的服务器，而朋友圈是一个单独的服务器(不管是图片还是视频)。</p><p>其他参数记录如下：</p><table><thead><tr class="header"><th>功能</th><th>丢包率</th><th>乱序率</th></tr></thead><tbody><tr class="odd"><td>发送图片</td><td>0.000000</td><td></td></tr><tr class="even"><td>发送小视频</td><td>0.000000</td><td></td></tr><tr class="odd"><td>接收图片</td><td></td><td>0.164835</td></tr><tr class="even"><td>接收小视频</td><td></td><td>0.112540</td></tr><tr class="odd"><td>朋友圈发图文</td><td>0.000000</td><td></td></tr><tr class="even"><td>朋友圈发视频</td><td>0.004049</td><td></td></tr><tr class="odd"><td>朋友圈收图文</td><td></td><td>0.027027</td></tr><tr class="even"><td>朋友圈收视频</td><td></td><td>0.040092</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;环境设置&quot;&gt;环境设置&lt;/h4&gt;&lt;p&gt;实验环境：&lt;/p&gt;&lt;ol style=&quot;list-style-type:decimal&quot;&gt;&lt;li&gt;iphone6 微信 WeChat6.3.16&lt;/li&gt;&lt;li&gt;macbook pro 分享wifi，网卡en0&lt;/li&gt;&lt;li&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.mkdef.com/tags/Python/"/>
    
      <category term="Plotly" scheme="http://blog.mkdef.com/tags/Plotly/"/>
    
      <category term="wireshark" scheme="http://blog.mkdef.com/tags/wireshark/"/>
    
      <category term="tcp" scheme="http://blog.mkdef.com/tags/tcp/"/>
    
      <category term="wechat" scheme="http://blog.mkdef.com/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>Brinson绩效分解</title>
    <link href="http://blog.mkdef.com/2016/05/11/Brinson%E7%BB%A9%E6%95%88%E5%88%86%E8%A7%A3/"/>
    <id>http://blog.mkdef.com/2016/05/11/Brinson绩效分解/</id>
    <published>2016-05-11T05:33:07.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作需要评估基金表现，所以尝试了使用最简单直观的Brinson模型来对基金的收益进行分解。通过Brinson分解，我们能够知道基金的收益中有多少来自于对债股的比例配置，有多少来自于对个股的选择。</p><p>首先需要说明的是，Brinson能够分解出的因素有很多，但是由于需求和实际数据的限制，这里只考虑资产配置和个股选择两个因素。其次，由于需要比较宽泛的应用到各种基金且各个历史阶段，所以只能对模型作很多简化处理，如果对单一基金做精细分析，Brinson分解能够取得更好的效果。</p><h4 id="单期brinson模型">单期Brinson模型</h4><p>其实Brinson模型的原理很简单，我们假设有一个基准线，也就是什么额外付出都没有的情况下，一个基金能够获得的收益。然后现在我们待分析的基金比基准多出了一部分收益，那Brinson模型就是用来告诉我们多出来的这部分收益是什么因素导致的。</p><p>进一步的，假设这些收益仅仅来自于两个因素，一个因素是资产配置，也就是多少用来买债券，多少用来买股票。如果一定时间段内，股票涨得好，多配一部分股票自然收益会更高一些。另一个因素是个股选择，同样多的钱买股票，我买的股票比你准，涨得比你多，自然我的收益就更一些。</p><p>我们用公式来表达，假设基金的实际收益率为<span class="math inline">\(R_{p}\)</span> ，资产配置为<span class="math inline">\(W_{p, i}\)</span>, 每种资产的收益率分别为<span class="math inline">\(r_{p, i}\)</span>，那么总的收益率就可以表示为</p><p><span class="math display">\[ R_{p} = \sum_{i} W_{p,i}r_{p,i} \]</span></p><p>同样，我们用来的参考的基准收益也可以这样分解，表示为</p><p><span class="math display">\[ R_{b} = \sum_{i} W_{b,i}r_{b,i} \]</span></p><p>那Brinson模型就把收益分为了四个部分，一个是基准线上的基准收益，第二个是由于你资产配置能力强造成的收益，第三个是由于选股准确造成的收益，最后一个就是由两个部分共同造成的收益。 用表格表示就是</p><table style="width:99%"><colgroup><col width="18%"><col width="40%"><col width="40%"></colgroup><thead><tr class="header"><th></th><th>基准行业权重 <span class="math inline">\(w_{b,i}\)</span></th><th>实际行业权重 <span class="math inline">\(w_{p,i}\)</span></th></tr></thead><tbody><tr class="odd"><td>基准行业收益率<span class="math inline">\(r_{b,i}\)</span></td><td>基准组合B <span class="math inline">\(r_{b}=\sum r_{b,i}w_{b,i}\)</span></td><td>配置组合A <span class="math inline">\(r_{a}=\sum r_{b,i}w_{p,i}\)</span></td></tr><tr class="even"><td>实际行业收益率<span class="math inline">\(r_{p,i}\)</span></td><td>选股组合S <span class="math inline">\(r_{s}=\sum r_{p,i} w_{b,i}\)</span></td><td>实际组合P <span class="math inline">\(r_{p}=\sum r_{p,i}w_{p,i}\)</span></td></tr></tbody></table><p>所以，对于每个时期的基金表现，找到相应的基准线，计算出以上四个值就可以了。这里我们选取沪深300指数为基准，基准资产配置则为80%股票和20%债券。</p><h4 id="数据采集">数据采集</h4><p>我们先来分析一下需要哪些数据，首先需要每一支基金在特定时期的收益率，这个数据来源<a href="http://www.etf88.com/datacenter/jj/jjdata_alljz_index.html" target="_blank" rel="external">易天富</a>，这个页面支持净值回查，就可以得到所有基金任意时期的收益率了，采集的方法可以参考另一篇文章。</p><p>我们需要知道这支基金的资产配置情况，这个可以在<a href="http://www.etf88.com/jj/001367/zcpz.shtml" target="_blank" rel="external">这个</a>页面查到。观察一下可以发现，这些数据来源于每个季度的季报，日期确定一年四次，为了简单起见，这里只取股票和债券的比例，其他部分的收益假设为0。需要注意到，这里的数据可能会有错误，有的时候会用0.46表示，有点时候用46.16表示。这个问题很好处理，大于等于1的统一除以100即可。</p><p>我们还需要沪深300指数的历史收益，这个数据可以用sohu的api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://q.stock.sohu.com/hisHq?code=zs_000300&amp;start=20151231&amp;end=20160331</div></pre></td></tr></table></figure><p>这个api是从<a href="http://q.stock.sohu.com/zs/000300/lshq.shtml" target="_blank" rel="external">这里</a>抓到的，改变日期就可以得到中间所有交易日的净值，非常方便。</p><p>最后我们还需要债券的收益率，从<a href="http://bond.money.hexun.com/data/yield.aspx" target="_blank" rel="external">和讯债券</a>可以查到国债的收益率曲线。在这个页面也可抓到api：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://bond.money.hexun.com/data/js/data/trans.aspx?date=2015-01-03</div></pre></td></tr></table></figure><p>如果不是交易日，查询结果为空，所以需要多次查询才能得到最近的收益率。结果也不是标准的json格式，处理起来略有一点点麻烦。另外，这个api需要添加浏览器头才能得到数据，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">req.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1581.2 Safari/537.36'</span>)</div></pre></td></tr></table></figure><p>剩下的就是简单的计算了，需要注意的是非交易日和停牌的处理，基本原则就是向内逐个查找。这样我们就能一个基金在某个季度的Brinson分解了。 贴一下结果：</p><p><img src="/uploads/Season_brinson_attribution.png"> <img src="/uploads/History_brinson_attribution.png"></p><p>分别是单个季度和历史的分解结果。</p><h4 id="基于基金经理的分解">基于基金经理的分解</h4><p>由于基金主要是由基金经理来管理，那么即使是相同的基金，如果基金经理不同，那么绩效收益肯定也不一样，所以如果能从基金经理的角度来做分解，会更有意义一些。</p><p>这里选了一个跳槽次数比较多的基金经理<a href="http://www.howbuy.com/fund/manager/30044540/" target="_blank" rel="external">王忠波</a>来分析，可以看到，他一共管理过四支不同的基金，我们在每个季度只取最新的一个基金作为代表。计算方法还是一样的，结果如下：</p><div class="figure"><img src="/uploads/manager_brinson_attribution.png"></div><h4 id="小结">小结</h4><p>可以看到，Brinson分解方法简单粗暴，个人认为理论上还是很有意义的，但是实际操作时，对于基准线的选择，对于各种数据的处理，导致几乎不可能精确的分析出结果，所以可以看出分析出来的结果波动较大，几乎看不出一致性，也就没有特别参考价值了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于工作需要评估基金表现，所以尝试了使用最简单直观的Brinson模型来对基金的收益进行分解。通过Brinson分解，我们能够知道基金的收益中有多少来自于对债股的比例配置，有多少来自于对个股的选择。&lt;/p&gt;&lt;p&gt;首先需要说明的是，Brinson能够分解出的因素有很多，但是由
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.mkdef.com/tags/Python/"/>
    
      <category term="Brinson" scheme="http://blog.mkdef.com/tags/Brinson/"/>
    
      <category term="基金" scheme="http://blog.mkdef.com/tags/%E5%9F%BA%E9%87%91/"/>
    
      <category term="Plotly" scheme="http://blog.mkdef.com/tags/Plotly/"/>
    
  </entry>
  
  <entry>
    <title>Macos进行局域网arp欺骗</title>
    <link href="http://blog.mkdef.com/2016/05/10/Macos%E8%BF%9B%E8%A1%8C%E5%B1%80%E5%9F%9F%E7%BD%91arp%E6%AC%BA%E9%AA%97/"/>
    <id>http://blog.mkdef.com/2016/05/10/Macos进行局域网arp欺骗/</id>
    <published>2016-05-10T03:09:02.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前知乎看到一篇通过手机app就能直接监听到局域网内的其他用户的数据包，并且自动抓取图片和嗅探密码的答案，觉得这样也能成功实在太夸张了。于是自己实现一下，App开发不来，就在Mac上进行好了（事实上用到的也都是别人写好的程序）</p><h4 id="安装工具">安装工具</h4><p>首先安装<a href="https://www.macports.org/" target="_blank" rel="external">Macport</a>, 它是一个类似于apt-get和brew的一个包管理工具，通过port我们可以很方便的安装需要的各种工具。</p><p>如果安装之后发现仍然找不到port命令的，可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=/opt/local/bin:/opt/local/sbin:$PATH</div></pre></td></tr></table></figure><p>将其加入到系统路径里来。</p><p>port安装好之后就可以开始安装各种工具了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo port install arpspoof</div><div class="line">sudo port install nmap</div></pre></td></tr></table></figure><p>其实还有<code>sslstrip</code>和<code>ettercap</code>，不过后面两个更多的用于攻击，我们只需要体验一下中间人攻击就好了，<del>事实上是ettercap安装不成功</del>。</p><h4 id="nmap扫描整个局域网段">nmap扫描整个局域网段</h4><p>直接执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nmap -sS 192.168.1.0/24</div></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Starting Nmap 7.12 ( https://nmap.org ) at 2016-05-09 17:50 CST</div><div class="line">Nmap scan report for 192.168.1.1</div><div class="line">Host is up (0.0022s latency).</div><div class="line">Not shown: 998 filtered ports</div><div class="line">PORT     STATE SERVICE</div><div class="line">80/tcp   open  http</div><div class="line">1900/tcp open  upnp</div><div class="line">MAC Address: ▇▇:▇▇:▇▇:▇▇:▇▇:▇▇ (Tp-link Technologies)</div><div class="line"></div><div class="line">Nmap scan report for 192.168.1.111</div><div class="line">Host is up (0.0062s latency).</div><div class="line">Not shown: 999 closed ports</div><div class="line">PORT      STATE SERVICE</div><div class="line">62078/tcp open  iphone-sync</div><div class="line">MAC Address: ▇▇:▇▇:▇▇:▇▇:▇▇:▇▇ (Apple)</div><div class="line"></div><div class="line">Nmap scan report for 192.168.1.112</div><div class="line">Host is up (0.000017s latency).</div><div class="line">All 1000 scanned ports on 192.168.1.112 are closed (500) or filtered (500)</div><div class="line"></div><div class="line">Nmap done: 256 IP addresses (3 hosts up) scanned in 51.06 seconds</div></pre></td></tr></table></figure><p>其中192.168.1.1是局域网的网关，192.168.1.111是我的手机，192.168.1.112是我的本机。这是特意趁家里只有我一个人的时候扫描的，一旦有其他人接入wifi，就会出现更多的结果。</p><p>暂时不清楚这个工具的原理，有的时候不会显示手机的结果，当然一个可能的原因是iphone待机时自动断wifi，而不是工具的锅。</p><p>扫描过后就可以通过查看路由表来查看局域网内的ip信息了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">~netstat -r</div><div class="line">Routing tables</div><div class="line"></div><div class="line">Internet:</div><div class="line">Destination        Gateway            Flags        Refs      Use   Netif Expire</div><div class="line">default            192.168.1.254      UGSc          323        0     en0</div><div class="line">127                localhost          UCS             1        0     lo0</div><div class="line">localhost          localhost          UH             28  4818622     lo0</div><div class="line">169.254            link#4             UCS             1        0     en0</div><div class="line">192.168.1          link#4             UCS             4        0     en0</div><div class="line">192.168.1.207      link#4             UHLWIi          1        2     en0</div><div class="line">192.168.1.208      link#4             UHLWIi          1        2     en0</div><div class="line">192.168.1.250/32   link#4             UCS             1        0     en0</div><div class="line">192.168.1.254/32   link#4             UCS             2        0     en0</div><div class="line">192.168.1.254      ▇▇:▇▇:▇▇:▇▇:▇▇:▇▇  UHLWIir       324       16     en0    171</div><div class="line">192.168.1.255      link#4             UHLWbI          1       12     en0</div><div class="line">224.0.0            link#4             UmCS            2        0     en0</div><div class="line">224.0.0.251        ▇▇:▇▇:▇▇:▇▇:▇▇:▇▇  UHmLWI          1        0     en0</div><div class="line">255.255.255.255/32 link#4             UCS             1        0     en0</div><div class="line"></div><div class="line">Internet6:</div><div class="line">Destination        Gateway            Flags         Netif Expire</div><div class="line">localhost          localhost          UHL             lo0</div><div class="line">fe80::%lo0         fe80::1%lo0        UcI             lo0</div><div class="line">fe80::1%lo0        link#1             UHLI            lo0</div><div class="line">fe80::%en0         link#4             UCI             en0</div><div class="line">shaobos-macbook-pr ▇▇:▇▇:▇▇:▇▇:▇▇:▇▇  UHLI            lo0</div><div class="line">fe80::%awdl0       link#9             UCI           awdl0</div><div class="line">shaobos-macbook-pr ▇▇:▇▇:▇▇:▇▇:▇▇:▇▇  UHLI            lo0</div><div class="line">ff01::%lo0         localhost          UmCI            lo0</div><div class="line">ff01::%en0         link#4             UmCI            en0</div><div class="line">ff01::%awdl0       link#9             UmCI          awdl0</div><div class="line">ff02::%lo0         localhost          UmCI            lo0</div><div class="line">ff02::%en0         link#4             UmCI            en0</div><div class="line">ff02::%awdl0       link#9             UmCI          awdl0</div></pre></td></tr></table></figure><p>这是我在公司未扫描时的结果，可以看到只包含部分信息，但是如果<code>ping</code>一个不在表内的ip，这个新的ip就会被添加到路由表中。</p><p>通过这个步骤，我们就能知道局域网里还有哪些机器，然后我们就可以选定一个目标，开始攻击了。</p><h4 id="arp欺骗">arp欺骗</h4><p>这里选用我的手机192.168.1.111进行攻击，使用<code>arpspoof</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arpspoof -i en0 -t 192.168.1.111 192.168.1.1</div></pre></td></tr></table></figure><p>这个命令是告诉192.168.1.111这个机器，我是192.168.1.1，也就是你的网关，你的包就发给我吧，这样我就能在我的en0上监听到来自192.168.1.111的发包了。</p><p>但是这样一来，192.168.1.111就断网了，因为它的包发给了我，而没能转发出去。这个时候手机上会出现一个比较奇怪的现象，就是微信能收到小伙伴的消息，但是却发不出去。实测有极少量的消息还是发送出去了，可能是由于我们的arp欺骗是持续反复进行的，中间的间隙导致了包还是发给了网管。但是无论如何，这个时候目标机器的网络连接是不正常的。</p><h4 id="ip转发">ip转发</h4><p>打开ip转发功能后，就能把192.168.1.111的包转发给网管了，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -w net.inet.ip.forwarding=1</div></pre></td></tr></table></figure><p>本来以为会有各种复杂的设置，比如哪些转发，哪些不转，比如怎么转，转到哪去之类的。结果发现，打开之后，我的手机直接就能正常上网了，丝毫没有异样。<del>这时，我们就能放心大胆的进行监听而不用担心被发现了</del>。</p><h4 id="抓包">抓包</h4><p>抓包的方法很多，最方便的还是<a href="https://www.wireshark.org/" target="_blank" rel="external">wireshark</a>。直接监听之前设置的端口en0，然后设置过滤条件<code>ip.src == 192.168.1.111</code>，然后就可以看到目标机器的各种请求了。</p><p>这里上个监听结果的图</p><div class="figure"><img src="/uploads/sniffer_result.png"></div><p>其中，右上角的小图是我的朋友圈截图，大图是我在手机上点开图片之后，在Mac上监听到的请求，然后在浏览器上打开的结果。如果是在看视频，则会监听到连续的视频片段，可以一段一段下载下来看到。</p><h4 id="more">More</h4><p>当然我们这里仅仅监听了目标机器发送的包，同样的原理，我们可以欺骗网关，我们才是目标机器，这样我们就能监听到双向的消息了，而且目标机器仍然能够正常上网。</p><p>在这基础上，通过<code>sslstrip</code>可以建立假的<code>https</code>链接，这样就能明文看到本来是通过<code>https</code>加密过的消息，但是这样一来，目标机器是否还能正常使用不明，有待后续尝试。</p><p>通过<code>ettercap</code>则可以方便的完成上述过程，并且自动嗅探出其中的账号密码信息，估计就是加入一些常用的账号密码字段，或者关键字来提取的吧。</p><h4 id="防范">防范</h4><p>可以看到，这个方法的杀伤力还是很可怕的，虽然伤害范围有限，但是如果应用到出租屋，宾馆这种环境中，还是非常危险的。所以在公共场合还是尽量少的链接公共wifi。</p><p>关于防范措施，要么没必要防范，比如自己家中的wifi，设好密码不让外人连就好，要么没有权限防范，比如宾馆这种，路由不归你管。如果要在自己机器这个层面上防范暂时不知道有没有什么简单的方法，windows机器可以安装360防火墙，手机不明。</p><p>所以最好的方法还是定期修改密码，所有账号都绑定手机和安全邮箱，在公共wifi不登录敏感的账号等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前知乎看到一篇通过手机app就能直接监听到局域网内的其他用户的数据包，并且自动抓取图片和嗅探密码的答案，觉得这样也能成功实在太夸张了。于是自己实现一下，App开发不来，就在Mac上进行好了（事实上用到的也都是别人写好的程序）&lt;/p&gt;&lt;h4 id=&quot;安装工具&quot;&gt;安装工具&lt;/
    
    </summary>
    
    
      <category term="osx" scheme="http://blog.mkdef.com/tags/osx/"/>
    
      <category term="arpspoof" scheme="http://blog.mkdef.com/tags/arpspoof/"/>
    
      <category term="wireshark" scheme="http://blog.mkdef.com/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>Hexo和Github搭建Blog</title>
    <link href="http://blog.mkdef.com/2016/04/17/Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BABlog/"/>
    <id>http://blog.mkdef.com/2016/04/17/Hexo和Github搭建Blog/</id>
    <published>2016-04-17T02:19:42.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/github_hexo.png"> ## Hexo</p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a>是一个很简洁好用的静态Blog框架，第一次看到是在<a href="http://liam0205.me/" target="_blank" rel="external">始终</a>的博客，当时觉得主题很漂亮，速度也还不错，在页面底下看到了<code>Hexo</code>，于是就去看了一下介绍，结果发现好简单啊。加上去年写了一学期<code>Latex</code>，觉得<code>Markdown</code>肯定只会更简单，于是就按照这个<a href="http://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="external">教程</a>也搭了一个，于是这篇日志基本就参(zhao)考(chao)这篇教程写了。</p><h2 id="准备工作">准备工作</h2><p>教程用的windows，我用的Mac，其实差不多，Mac还简单一些，正好给了我个机会证明这篇日志<del>是原创</del>不全是照抄的。</p><h3 id="homebrew">Homebrew</h3><p>Mac下缺的东西都可以用<a href="http://brew.sh/" target="_blank" rel="external">Homwbrew</a>来装，很方便。打开就是安装命令。</p><h3 id="node.js">Node.js</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install npm</div></pre></td></tr></table></figure><h3 id="hexo">hexo</h3><p>然后就可以安装<code>hexo</code>了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div><div class="line">$ npm install hexo --save</div></pre></td></tr></table></figure><h2 id="hexo配置">Hexo配置</h2><h3 id="初始化">初始化</h3><p>执行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</span></div><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</div><div class="line">$ npm install</div><div class="line"></div><div class="line"><span class="comment"># 新建完成后，指定文件夹的目录如下</span></div><div class="line">.</div><div class="line">├── _config.yml</div><div class="line">├── package.json</div><div class="line">├── scaffolds</div><div class="line">├── scripts</div><div class="line">├── <span class="built_in">source</span></div><div class="line">|      ├── _drafts</div><div class="line">|      └── _posts</div><div class="line">└── themes</div></pre></td></tr></table></figure><h3 id="安装插件">安装插件</h3><p>这个我是按照教程来的，但是有几个明显用不到的就可以不装了，比如git之外的几个<code>deployer</code>， 还有好几个<code>generator</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-index --save</div><div class="line">$ npm install hexo-generator-archive --save</div><div class="line">$ npm install hexo-generator-category --save</div><div class="line">$ npm install hexo-generator-tag --save</div><div class="line">$ npm install hexo-server --save</div><div class="line">$ npm install hexo-deployer-git --save</div><div class="line">$ npm install hexo-deployer-heroku --save</div><div class="line">$ npm install hexo-deployer-rsync --save</div><div class="line">$ npm install hexo-deployer-openshift --save</div><div class="line">$ npm install hexo-renderer-marked@0.2 --save</div><div class="line">$ npm install hexo-renderer-stylus@0.2 --save</div><div class="line">$ npm install hexo-generator-feed@1 --save</div><div class="line">$ npm install hexo-generator-sitemap@1 --save</div></pre></td></tr></table></figure><h3 id="预览">预览</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo g <span class="comment">#生成public静态文件</span></div><div class="line">$ hexo s <span class="comment">#本地发布预览效果</span></div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure><p>本地做的所有更改都会实时的更新，可以随时看到刚刚所做的修改，非常方便，平时也可以另外开一个进程一直跑，然后再修改。</p><h3 id="新文章和新页面">新文章和新页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo new &quot;文章标题&quot;</div><div class="line">hexo new page &quot;关于&quot;</div></pre></td></tr></table></figure><p>这两个命令其实都是生成的<code>Markdown</code>文件，如果想要修改文章或者编辑页面，编辑相应的<code>.md</code>文件就可以了。</p><h2 id="github配置和自动部署">Github配置和自动部署</h2><p><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>是一个Github开发的给用户托管静态网页的功能，自由度和稳定性都非常高，十分良心。</p><h3 id="github">github</h3><ol style="list-style-type:decimal"><li>新建项目，名字必须和用户名一致，格式为<code>username.github.io</code>；</li><li>稍等几分钟之后就能访问静态主页了<code>http://username.github.io</code>；</li><li><p>编辑<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: &lt;repository url&gt;</div><div class="line">  branch: [branch]</div><div class="line">  message: [message]</div></pre></td></tr></table></figure></li><li><p>命令<code>hexo d</code>就会自动把<code>public</code>里的文件全部同步到github上，并且访问主页就能看到所做的修改。</p></li></ol><h3 id="域名设置">域名设置</h3><ol style="list-style-type:decimal"><li>在<code>public</code>目录下创建<code>CNAME</code>文件，里面填写自己的域名；</li><li>给自己的域名添加CNAME记录，推荐<a href="https://www.dnspod.cn/" target="_blank" rel="external">DNSPod</a>，配置页有详细的介绍；</li><li>将<code>CNAME</code>文件同步到Github上，很快就能通过自己的域名访问网站了。</li></ol><h2 id="hexo主题设置">Hexo主题设置</h2><p>目前用的是<a href="http://theme-next.iissnan.com/getting-started.html#activate-next-theme" target="_blank" rel="external">Next</a>，链接有详细的安装和设置教程。</p><p>参考其中头像的设置，可以用类似的方法设置favicon，平时在文章中插入图像的链接也是一样的。</p><h2 id="关于markdown编辑器">关于Markdown编辑器</h2><p>其实我一直用<code>Sublime Text</code>写代码，我相信它也一定能够写<code>Markdown</code>，不过我估计它不支持所见即所得，所以我也没有去配置它。</p><p>目前我用的是<code>MacDown</code>，基本我能想到的它都支持，包括代码高亮，而且效果基本和Hexo生成的一样，目前看来是我用过的最好的<code>Markdown</code>编辑器，唯一的遗憾在于不支持文档管理，不过这个功能有没有都有一定道理。</p><p>目前发现的和<code>Hexo</code>的区别有：</p><ol style="list-style-type:decimal"><li><code>Hexo</code>文件前面有一块配置区域<code>Macdown</code>解析不了；</li><li>插入图片的文件路径不一致；</li><li>#开头的标题要空格，不然<code>Hexo</code>不会解析成标题，而<code>Macdown</code>没有这个问题；</li><li>父标题和子标题的#数目要连续，不然生成的目录可能会有bug；</li><li>使用<code>MathJax</code>的时候，_前面要加<code>\</code>，不然解析不正确；</li><li>使用<code>MathJax</code>的时候，行内公式使用单个<code>$</code>，<code>MacDown</code>默认使用两个<code>$</code>, 设置中可以更改；</li></ol><h2 id="使用mathjax">使用MathJax</h2><p>参考<a href="http://theme-next.iissnan.com/third-party-services.html#others" target="_blank" rel="external">Next的官方文档</a></p><p>编辑 主题配置文件， 将 <code>Mathjax</code> 下的 enable 设定为 true 即可。 cdn 用于指定 <code>MathJax</code> 的脚本地址，默认是 <code>MathJax</code> 官方提供的 CDN 地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># MathJax Support</span></div><div class="line">mathjax:</div><div class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></div><div class="line">  cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</div></pre></td></tr></table></figure><h2 id="备份源文件">备份源文件</h2><p>来源：<a href="http://www.yuthon.com/2016/04/11/Tips-for-Hexo-configuration/" target="_blank" rel="external">Tips for Hexo configuration</a> 之前采用新建一个repo的方法备份文件，然后发现使用<code>hexo d</code>的时候，会部署所有的文件，然后也没有找到办法恢复。</p><p>其实，只需要新建一个分支就可以备份源文件了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git checkout -b <span class="built_in">source</span></div><div class="line">$ git add .</div><div class="line">$ git commit -m <span class="string">"init"</span></div><div class="line">$ git remote add origin git@github.com:saukymo/saukymo.github.io.git</div><div class="line">$ git push origin <span class="built_in">source</span></div></pre></td></tr></table></figure><h2 id="部署后自动备份源文件">部署后自动备份源文件</h2><p>来源: <a href="http://notes.wanghao.work/2015-07-06-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html" target="_blank" rel="external">自动备份Hexo博客源文件</a></p><p>安装<code>shelljs</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save shelljs</div></pre></td></tr></table></figure><p>在<code>Hexo</code>根目录的<code>scripts</code>文件夹下新建一个js文件，文件名随意取， 如果没有<code>scripts</code>目录，请新建一个。</p><p>然后在脚本中，写入以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'shelljs/global'</span>);</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	hexo.on(<span class="string">'deployAfter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//当deploy完成后执行备份</span></div><div class="line">		run();</div><div class="line">	&#125;);</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为："</span> + e.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!which(<span class="string">'git'</span>)) &#123;</div><div class="line">		echo(<span class="string">'Sorry, this script requires git'</span>);</div><div class="line">		exit(<span class="number">1</span>);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		echo(<span class="string">"======================Auto Backup Begin==========================="</span>);</div><div class="line">		cd(<span class="string">'~/Documents/mkdef'</span>);    <span class="comment">//此处修改为Hexo根目录路径</span></div><div class="line">		<span class="keyword">if</span> (exec(<span class="string">'git checkout source'</span>).code !== <span class="number">0</span>)&#123;</div><div class="line">			echo(<span class="string">'Error: Git checkout branch source failed'</span>);</div><div class="line">			exit(<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (exec(<span class="string">'git add --all'</span>).code !== <span class="number">0</span>) &#123;</div><div class="line">			echo(<span class="string">'Error: Git add failed'</span>);</div><div class="line">			exit(<span class="number">1</span>);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (exec(<span class="string">'git commit -am "From auto backup script\'s commit"'</span>).code !== <span class="number">0</span>) &#123;</div><div class="line">			echo(<span class="string">'Error: Git commit failed'</span>);</div><div class="line">			exit(<span class="number">1</span>);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (exec(<span class="string">'git push origin source'</span>).code !== <span class="number">0</span>) &#123;</div><div class="line">			echo(<span class="string">'Error: Git push failed'</span>);</div><div class="line">			exit(<span class="number">1</span>);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		echo(<span class="string">"==================Auto Backup Complete============================"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意修改为自己的远程仓库名和相应的分支名。</p><p>此时，运行<code>hexo d</code>后的结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div><div class="line">INFO  Deploying: git</div><div class="line">INFO  Clearing .deploy_git folder...</div><div class="line">INFO  Copying files from public folder...</div><div class="line">[master d747a0d] Site updated: 2016-05-29 01:22:33</div><div class="line"> 5 files changed, 7 insertions(+), 13 deletions(-)</div><div class="line">To git@github.com:saukymo/saukymo.github.io.git</div><div class="line">   bb4cdbd..d747a0d  HEAD -&gt; master</div><div class="line">Branch master <span class="built_in">set</span> up to track remote branch master from git@github.com:saukymo/saukymo.github.io.git.</div><div class="line">INFO  Deploy <span class="keyword">done</span>: git</div><div class="line">======================Auto Backup Begin===========================</div><div class="line">Already on <span class="string">'source'</span></div><div class="line">M	<span class="string">"source/_posts/Hexo\345\222\214Github\346\220\255\345\273\272Blog.md"</span></div><div class="line">M	themes/next</div><div class="line">[<span class="built_in">source</span> 1786b36] From auto backup script<span class="string">'s commit</span></div><div class="line"> 1 file changed, 5 insertions(+)</div><div class="line">To git@github.com:saukymo/saukymo.github.io.git</div><div class="line">   49ab33a..1786b36  source -&gt; source</div><div class="line">==================Auto Backup Complete============================</div></pre></td></tr></table></figure><h2 id="压缩静态资源">压缩静态资源</h2><p>安装<a href="https://github.com/unhealthy/hexo-all-minifier" target="_blank" rel="external">hexo-all-minifier</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-all-minifier --save</div></pre></td></tr></table></figure><p>然后 <code>hexo g</code>时就会自动压缩静态资源</p><h2 id="使用pandoc解析">使用pandoc解析</h2><p><a href="http://pandoc.org/" target="_blank" rel="external">pandoc</a>是一个比markdown更加强大的解析工具，使用它可以避免<code>MathJax</code>和<code>markdown</code>冲突的问题，而且二者的语法也大同小异。</p><p>首先安装<code>pandoc</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install pandoc</div></pre></td></tr></table></figure><p>然后用<code>npm</code>安装<code>hexo-renderer-pandoc</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-renderer-pandoc --save</div></pre></td></tr></table></figure><p>这里我不知道怎么设置<code>Hexo</code>使用哪一个解析器，所以我直接删掉了另一个解析器<code>hexo-renderer-marked</code></p><p>此时，新生成的页面里，所有的公式应该都不需要转义下划线了。</p><p>但是，<code>pandoc</code>对表格的支持没有<code>markdown</code>那么智能，<code>-</code>的数目和表格的宽度严格相关，两端也需要用<code>|</code>闭合，才能正常显示。坏处自然是设置更加麻烦了，好处则是有利于微调。不过暂时还不清楚什么时候表格里的内容会溢出，什么时候会自动换行。</p><p>据说<code>pandoc</code>可以用来写论文，之后可以尝试一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/github_hexo.png&quot;&gt; ## Hexo&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;是一个很简洁好用的静态Blo
    
    </summary>
    
    
      <category term="Hexo" scheme="http://blog.mkdef.com/tags/Hexo/"/>
    
      <category term="github" scheme="http://blog.mkdef.com/tags/github/"/>
    
      <category term="MathJax" scheme="http://blog.mkdef.com/tags/MathJax/"/>
    
      <category term="Next" scheme="http://blog.mkdef.com/tags/Next/"/>
    
      <category term="Pandoc" scheme="http://blog.mkdef.com/tags/Pandoc/"/>
    
  </entry>
  
  <entry>
    <title>pypy加速抓取Sina后复权数据</title>
    <link href="http://blog.mkdef.com/2016/04/14/pypy%E5%8A%A0%E9%80%9F%E6%8A%93%E5%8F%96Sina%E5%90%8E%E5%A4%8D%E6%9D%83%E6%95%B0%E6%8D%AE/"/>
    <id>http://blog.mkdef.com/2016/04/14/pypy加速抓取Sina后复权数据/</id>
    <published>2016-04-14T06:07:36.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pypy">pypy</h2><p><a href="http://pypy.org/" target="_blank" rel="external">PyPy</a>是一个独立的解析器， 通过即时编译(JIT,Just-in-time)代码避免逐行解释执行来提升运行速度。我们一般使用的Python一般是使用C实现的,所以一般又叫CPython。PyPy采用python实现，速度最快可以达到CPython的10倍左右。</p><p>PyPy对纯Python的模块支持的非常好，支持的模块可以在<a href="http://packages.pypy.org/" target="_blank" rel="external">这里</a>看到。但是PyPy对C模块的支持还不是很好，主要是对numpy的支持完成度还不够高，所以常用的一些科学运算库也就都不兼容PyPy了。所以个人感觉PyPy主要是应用在服务器和爬虫上。</p><h2 id="multiprocessing.dummy">multiprocessing.dummy</h2><p><code>multiprocessing.dummy</code>和<code>multiprocessing</code>是两个执行并行任务的库，其中前者是多线程库，后者是多进程库，但是具有相同的api，所以可以很方便的在多线程和多进程之间切换。</p><p>由于GIL的原因，Python的多线程其实是单线程交替执行的，所以对于CPU密集的任务来说，多线程其实并不会有很好的效果。但是对于IO密集型的任务，多线程实现简单轻量也有很好的加速效果，值得一试。</p><p>举一个简单的爬取网页的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2 </div><div class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool <span class="keyword">as</span> ThreadPool </div><div class="line"></div><div class="line">urls = []</div><div class="line"></div><div class="line">pool = ThreadPool(<span class="number">4</span>) </div><div class="line">results = pool.map(urllib2.urlopen, urls)</div><div class="line"></div><div class="line">pool.close() </div><div class="line">pool.join()</div></pre></td></tr></table></figure><p>这个例子采用了4个线程，通过<code>pool.map()</code>来分发任务，结果依次保存在<code>results</code>中，其中<code>pool.join()</code>是等待所有线程结束之后再执行后续的代码。</p><h2 id="tushare">tushare</h2><p><a href="http://tushare.org/" target="_blank" rel="external">TuShare</a>是一个免费、开源的python财经数据接口包。它的数据也是从网上各种数据源抓取整理过来的，并且采用统一的结构，返回pandas的dataframe。并且它整合了通联的数据，所以这个包的数据数量和质量都是很不错的。</p><p>我的任务是采集A股市场的复权数据，tushare本来可以轻松完成这个任务，但是速度特别慢， 2800支个股4个线程采集需要将近50分钟的时间，对于一个需要每天运行一次的程序来说时间有点长。通过查看源代码，发现其实它是抓取的<a href="http://vip.stock.finance.sina.com.cn/corp/go.php/vMS_FuQuanMarketHistory/stockid/600900.phtml?year=2016&amp;jidu=1" target="_blank" rel="external">sina的复权数据页面</a>，而且是每支股票单独抓取的，所以它一共调了将近3K次api来请求整个html页面，然后从中解析出数据。(其实是6K次，因为新浪那个页面是按季度来查询的，然后当时正好跨越了第一和第二两个季度)</p><p>于是自然想试试用PyPy来加速了，加上之前也没有用过PyPy，正好通过这个机会来测试一下PyPy的效果。</p><h2 id="pypy的下载和安装">PyPy的下载和安装</h2><p>首先在官网的<a href="http://pypy.org/download.html" target="_blank" rel="external">下载</a>页面下载最新版本的PyPy：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://bitbucket.org/pypy/pypy/downloads/pypy-5.0.1-linux64.tar.bz2</div></pre></td></tr></table></figure><p>然后解压放到任意位置，并用PyPy的作为virtualenv的解释器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">virtualenv -p /path/to/pypy/bin/pypy env</div><div class="line">source env/bin/activate</div></pre></td></tr></table></figure><p>此时运行python就能看到PyPy的信息了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Python 2.7.10 (bbd45126bc69, Mar 18 2016, 21:35:08)</div><div class="line">[PyPy 5.0.1 with GCC 4.8.4] on linux2</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div></pre></td></tr></table></figure><p>此时就可以通过<code>pip</code>来安装各种需要用到的第三方包了，这里主要是用到<code>lxml</code>，通过这个包可以很容易的解析html页面，从而提取出表格中的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</div><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</div><div class="line"><span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen, Request</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_h_data</span><span class="params">(share, quarters)</span>:</span></div><div class="line">     data = &#123;&#125;</div><div class="line">     <span class="keyword">for</span> y, q <span class="keyword">in</span> quarters:</div><div class="line">         url = <span class="string">"http://vip.stock.finance.sina.com.cn/corp/go.php/vMS_FuQuanMarketHistory/stockid/%s.phtml?year=%d&amp;jidu=%d"</span>%(share.get(<span class="string">'code'</span>), y, q)</div><div class="line">         request = Request(url)</div><div class="line">         text = urlopen(request, timeout=<span class="number">10</span>).read()</div><div class="line">         text = text.decode(<span class="string">'GBK'</span>)</div><div class="line">         page = html.parse(StringIO(text))</div><div class="line">         table = page.xpath(<span class="string">'//*[@id=\"FundHoldSharesTable\"]/tr'</span>)</div><div class="line"></div><div class="line">         <span class="keyword">for</span> tr <span class="keyword">in</span> table[<span class="number">1</span>:]:</div><div class="line">             date = tr[<span class="number">0</span>].text_content().strip()</div><div class="line">                 data[date] = tr[<span class="number">3</span>].text_content()</div><div class="line"></div><div class="line">     share[<span class="string">"data"</span>] = data</div><div class="line">     <span class="keyword">return</span> share</div></pre></td></tr></table></figure><p>可以看到，通过<code>lxml</code>来解析html页面是非常方便的，这个地方由于Sina本身的表格是没有<code>&lt;tbody&gt;</code>标签的，所以只能通过<code>&lt;tr&gt;</code>标签来提取数据，然后把第一行表格头去掉，由于我只需要收盘价，所以直接取的<code>tr[3]</code>的内容。</p><p>事实上，如果这里使用<code>pandas</code>，可以通过<code>read_html()</code>来直接将表格转换成<code>pandas.DataFrame</code>。但是由于PyPy不支持<code>pandas</code>，所以这里的数据只能手工提取出来。</p><h2 id="exception-and-retry">Exception and Retry</h2><p>由于这里需要通过网络请求第三方的数据，所以为了避免因为各种意外情况导致的错误，我们需要用<code>try</code>把请求的部分包起来，使得即使个别数据出现了错误或者某一次请求意外地没有成功时，我们能够继续请求其他的数据或者重复请求失败的数据。</p><p>之所以把这一块单独写出来，是因为一开始自己写了一个很丑陋的<code>Retry</code>过程，当时就觉得这么简单的功能应该有更加优雅的实现，结果很快就看到了一个不错的实现方式，所以这里把这个更好的方法写下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">	<span class="keyword">try</span>:</div><div class="line">		<span class="comment"># Do some thing </span></div><div class="line">		<span class="keyword">break</span></div><div class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">		<span class="keyword">print</span> e</div><div class="line">		</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="comment"># Continue do something</span></div><div class="line">		<span class="keyword">pass</span></div></pre></td></tr></table></figure><p>这样就可以很简单实现重复3次的功能了！</p><h2 id="functools.partial">functools.partial</h2><p>这里<code>get_h_data</code>含有两个参数，但是<code>pool.map()</code>只能传一个参数，当然我们也能很简单的将并行的函数改写成一个参数的新函数，但是我们可以通过<code>functools.partial</code>来更加优雅的封装它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line">quart_get_h_data = functools.partial(get_h_data, quarters=quarters)</div></pre></td></tr></table></figure><p>然后<code>quart_get_h_data()</code>就可以当做只有一个参数的函数来使用了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pool = ThreadPool(<span class="number">4</span>)</div><div class="line">result = pool.map(quart_get_h_data, share_list)</div><div class="line">pool.close()</div><div class="line">pool.join()</div></pre></td></tr></table></figure><p>使用PyPy运行的程序抓取时间只需要5分钟！是之前的10倍。当然由于程序实现的方法也不一样，所以这个10倍并不准确，但是由于时(lan)间(ai)原(fa)因(zuo)，我也不去比较PyPy和Cython的效率差别了。</p><h2 id="总结">总结</h2><p>这次的爬虫很好的解决了爬数据的效率问题，可以看到PyPy安装使用简单，效率超级高，虽然使用限制较大，但是对于第三方依赖较小的程序，PyPy绝对是一个很好的选择。</p><p>目前PyPy的开发团队主要的工作就是在支持<code>numpy</code>，如果能够完美的支持<code>numpy</code>，那么Python的速度问题也就能得到很好的解决，以后用Python做科学计算也就更加方便了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;pypy&quot;&gt;pypy&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://pypy.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PyPy&lt;/a&gt;是一个独立的解析器， 通过即时编译(JIT,Just-in-time)代码避免逐行解释执行来提升
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.mkdef.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://blog.mkdef.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="pypy" scheme="http://blog.mkdef.com/tags/pypy/"/>
    
      <category term="multiprocessing" scheme="http://blog.mkdef.com/tags/multiprocessing/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.mkdef.com/2016/04/13/hello-world/"/>
    <id>http://blog.mkdef.com/2016/04/13/hello-world/</id>
    <published>2016-04-12T16:00:00.000Z</published>
    <updated>2016-11-26T09:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
